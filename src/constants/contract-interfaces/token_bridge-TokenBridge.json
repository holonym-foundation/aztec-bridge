{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "TokenBridge",
  "functions": [
    {
      "name": "claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12741719456629472615": {
            "error_kind": "string",
            "string": "User's clean hands SBT has expired, cannot claim tokens"
          },
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "1336631728488611437": {
            "error_kind": "string",
            "string": "User does not have a clean hands SBT, cannot claim tokens"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim_public"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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vr/l2ve3XPv+lmvf33Lt+1uufX/LtR9uufbDLdd+uOXaD7dc++GWaz/ccu2HW679cMu1H2659m95rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnvLc332luf63C3P9blbnutztzzX5255rs9N9pZvcbd8S5Fr36qw7OXwWJnOvLqh3G+yXJnnBauNPooefZI8+jLPTVYbvRI9ei169Eb06K3o0TvRoxc91yrRc60SPdcq0XOtbnyu9eseo9OkN4bf+GSbG37js21u+I1Pt7nhNz7f5obf+ISbG36h/ZIOd3dwhZ4rz31LuuNbCj1XnvsWdcu36Fu+xdzyLfaWb3G3fIu/5VtuufbNLde+ueXat7dc+/aWa9/ecu3bW659e8u1b2+59u0t17695dq3t1z79pZr391y7btbrn13y7Xvbrn23S3Xvrvl2ne3XPvulmvf3XLtu1uufX/Lte9vufb9Lde+v+Xa97dc+/6Wa9/fcu37W659f8u172+59sMt13645doPt1z74ZZrP9xy7Ydbrv1b9lh14ZZrP9xy7Ydbrv14y7Ufb7n24y3Xfrzl2o+3XPvxlms/3nLtx1uu/XjLtR9vufbTLdd+uuXaT7dc++mWaz/dcu2nW679dMu1n2659tMt136649r303TLt6hbvqWj908cL2b7qaOXdOVKteOU2tFrunKldvSerlypHb2oK1fqp39xtTH8H70sRq8vgDFGPd+J7L+Hn0QP/+P7P394+Or+4Zu0HByt1pmL6mcvoJ+WWr32L8d+Xykf39+6qWLNSMXakYp1IxXrRyo2jFRsHKnYNFCxehqp2JEclB7JQemRHNTH35nQVLEjOSg9koPSIzkoPZKD0iM5KDOSgzIjOSgzkoMyIzmoj795pqliR3JQZiQHZUZyUGYkB2X7mmftcrB3aqPYvu7Gfvlk7+NGsa3fjZ1ya7HG/lbsXEDrd9hsAa3fNbMFtH4nzBbQfH9o1bMAl7nglQ9+2bLl8ffjQl+O/164d813iGXLbX7uKltu811i2XKb7xPLlmtbKnceUlMOYh5SU55gHlKFWd66Zd6LLmYOVsGvOg3++WCh85sz6vrJvx4iPD44rhVG+/xcZRZFR4DZBiYBzCYwfgKY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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "portal",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "cleanHandsSBTContract",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "exit_to_l1_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12741719456629472615": {
            "error_kind": "string",
            "string": "User's clean hands SBT has expired, cannot claim tokens"
          },
          "1336631728488611437": {
            "error_kind": "string",
            "string": "User does not have a clean hands SBT, cannot claim tokens"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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EwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAAT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",
      "debug_symbols": "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",
      "brillig_names": [
        "exit_to_l1_public"
      ]
    },
    {
      "name": "get_config_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "token",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "portal",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::eth_address::EthAddress"
                }
              },
              {
                "name": "cleanHandsSBTContract",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAAUSUAAABZLgQAAYBELgQAAoBFLgQAA4BGKAIABASARCcCBQQDOw0ABAAFKACAQwQAAyYlAAAB2R4CAAIAHgIAAwAzOAACAAMABCcCAgEBJAIABAAAAIIlAAACAh4CAAIJJwIDAAEKOAIDBCQCAAQAAACeJQAAAhQnAgIAAC0IAQQnAgUEBAAQAQUBJwMEBAEAKAQCBS0MBQYtDgIGACgGAgYtDgIGACgGAgYtDgIGLQgBAgAAAQIBLQ4EAicCBAQAJwIFBAEtDAQBIwAAAPUNKAABgEMABCQCAAQAAAF2IwAAAQotDQIBADgBBQMtDQMCJwIDBAIAOAEDBS0NBQQcDAQDACwCAAUAAAAAAAAAAAAAAAAA//////////////////////////8OOAMFBiQCAAYAAAFhJQAAAiYBKAABgEMABS0NBQMtDAIBLQwEAiYtDQIEHAwBBgAAOAMGBy8MAAcABicCCAQDDDgBCAkkAgAJAAABoSUAAAI4LgQABIADKACABAQABCUAAAJKLgiABQAHACgHAggAOAgBCS0OBgktDgcCADgBBQQtDAQBIwAAAPUoAIAEBHgADQAAAIAEgAMkAIADAAACASoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF12M4sTxmeyc8AQECJioBAAEFWgLkG7UeqZ88AQECJioBAAEF6J0J/qERLQ48AQECJi4BgAOABgsAgAYAAoAHJACABwAAAmUjAAACcC4AgAOABSMAAALXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAAsMuAYAKgAguAoAIgAsBAIAKAAKACgEAgAsAAoALIwAAApIoAYAFBAABAwCABgACgAYjAAAC1yYuABjKGMo=",
      "debug_symbols": "7VvbiuMwDP2XPOfBtiTLml9ZhqGXdAiUtvSysJT++zozdZqmIdktoQR7XkpcjiMdH9syUnzOlsX89PlRblbbQ/b265ytt4vZsdxufOt8ybP5vlyvy8+P5t+Zqn4Ev/CH3WxTNQ/H2f6YvWl0SuVZsVlWzwLk37Eq14Vvabzkj3hlTIArNA207kCjRbqi0RLWaEsdYIdOrmBHiprg9zwTGcd9CTa8x/I69/1gjeM/uXr43dDwa2IOaAvQ778QB7JitWv7r83Y/mtz7/+XFX6FFUOvsAKq24piXVtRAgNW2EOucPazd0BDgzZoaKy0NQT6F4/ueVf9UD3Z70l7BE/2c539WIVB0WxuvahrBIEw7G9gG6tYW9M1BYwLa8bL3UBLF5rJhgnD5AakZANh7frHh+VoIR2qnAxVNulQTUdVl46qLh1VRadDlVKhapRKhyqmQ1WSoaqTORganUywMSaZI4TBqIKNxZqqbeeEjLURUQUM6S8GeqDKU4+rdS6HrRrI9PlwIsGT6vk2hb3Nb7ZTn8Pjsp16dB2VrcOk2CalrUz98PQfbJEleI0O7rl2ZI7r5L9WSt3A1JmTNvVWb80A1udmoc6SWzeAJg5gkkZ1xn2rM/X0bsrqAEQU8+JTByM6f0Wozs/ONmF1KKJTweAZCOzU89qjsmVMJdsAHFN1HCS8mvHhYxtwMSVBwak+qlGpavlG1faDtfbO1js8CLRHRmJa2r3ZNZCY6hu9VFEloyrqmJL+A1RjKuX0UzVRxaZeqhBTMX2AakxVq36qGNOHLwNUkynQIaWjKqWzVimRg+HFt37P9uVsvi6uN2FWp82icTHm+GdXtO7I7PbbRbE87YvqtsztokwVtLSCXBt8ry5u+KbnJKpqVItEOBfxFr3Vvw==",
      "brillig_names": [
        "get_config_public"
      ]
    },
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dCZgcRfXv2ZlNsptsdklIQiCEI4QQSMj0zOwFBDbkIvd9H7C7MxsCgQAJyM0CcokHoCiKggcKgiIqIoIHoggi4IUHiHihf2/xRlH8v0q6dt++fdPbk3m16UdS3/e+6emqfvWrV++9elVd3Z3wdqYzKj3vidTO4wRQMvitADqYnKtkzg1mztUw52qZc/sw50YCtZBzBzHlDmbOHcKcO5Q5NyE4h1NF8NsS/KbLS/4ExCubbsjlCo2Zgp/1W9OZ5ram+nSuvq2hyW/y65vq85mmbLbQlGtqbG5rbkw3+7lswe+ob852BMxqknK4evRT0r0cMPZy5TDUkRyGMnJICMshKagPKdJXLnEn5HilGbhSvJu6GBrhDOwn4ezrxVo4vj3AsqhN7vyts9rf5aHh4EVyro6xjKRDIe6iZWQCy/BrBb1NnZy32WGxg7xuBQxTynJx1zK4d5UnxrtP0iFgw7zY0LOr/PcRHC6GCSqWKxkajAlhGQ5Lyno46XbXBe2WClssX8n+Hi4oQ+ycDV8T8qa8bqdN0x4aDvguZSA5MOA+2zf4MyL4HZnsozPLVcxRu96QLD1hsA3zdiqjxWoa9FpwPAIdj0THo4Jje91+8H800P5AByS7z7uSwRixzvQbXeI8UE7pclxfjUF9YsgeHxjSV2Ph/0EmQjSOKOgrQxVe/4TfkoboEudYQZwDEM5DAwcxLvg9LPgdH/weHgQERwTlJ8D/I4AmAh0JdBTQJKDJQEcDTQEyHslMVjNAWaAcUD1QA1AjUBNQM9AxQMcCHQc0Feh4oBNMO4GmAZ0INB1oBtBMoFlAs4FOApoDNBdoHtB8oAVAC+l05PBg6lFK6JwuL/njhEdqmxYlHQJelJTnu9hxuJsuL+1o92I0PArxTfensh3mSNmWJB0CXuJA2ZbGXNlMu5cqV7bxjpRtWdIh4GUOlG15zJXNtHu5A2VzgXVxYBjSse6KpE4jO9yRka1MOgS80oGRrYq5kZl2r1JiZMYZrHBgZKv7afJULs41u44zR09wE99xaIJ7GDo+HB2vIRPftfB/HdB6oA3MIkVSWAcER29/raBtbhR2eLRvNqI+WIeO16PjDaRvTob/pwC1ArUle/KT1EvjP1Y7sMt2wb42ba/y+mdl+FBH/sQTxZlpcsc7nUkg2dpFlzzIpQDUAbQJ6FSgzUCnAZ0OtAXoDKAzgbYCnQV0NtA5QNuAtgOdC3Qe0BuAzge6AOhCoIuALga6BOhSoMuAOoEuB7oC6EqgNwJdBXQ10DVA1wJdB/QmoOvpoks+2b0CaM8VmHMdzLlNzLlTmXObmXOnMedOZ85tYc6dwZw7kzm3lTl3FnPubObcOcy5bcy57cy5c5lz5zHn3sCcO585dwFz7kLm3EXMuYuZc5cw5y5lzl3GnOtkzl3OnLuCOXclc+6NzLmrmHNXM+euYc5dy5y7jjn3Jubc9cluJ2nTxOC3JfhNl5d6OM1yB468AK9Cx85UkOOV75Dj1bxJjpd/qhivgr9ZjFe7f5oYryb/dDFeaX+LFK9C2j9Dild72j9TildT2t8qxQts+ywhXgXgdbYQr3bgdY4QrybgtU2Il/GF22V4FQyvc2V4tRte58nwajK83iDDa8fYcb4Ir8IOXheI8GrfwetCEV5NO3hdJMJr51h7sQSvwk5el0jwat/J61IJXk07eV0mwSuITToFeOUDXpcL8GoLeF0hwKsx4HVl+by69p6+sXxevuV1Vdm8mjosr6vL59VmeV1TPi8br/rXls2rsYvXdWXzqu/i9aayefldvK5PulkUodsd4zB3sLzeLNfmHdv4pBeqzAJhe1J+4e4twn0ttaU1SL7Z/ZMX7BvTz29xIMe3KpCjpI7nHcnxbY58jzTOG5TgvHHXcWboCYON3uwwem9varwNHd+Ajm9M9rzZcRP8fzvQO4BuTha/2ZEuL/lm12DBgY7+K+X25mu5+Eybb3LQ7n+n3Oh8SrjfbxKMC94p6DMF9cbX0hdHCPbFu5JubDhOdsH52HciX/quiD72Fvj/bqD3AN3q0MeaXdkdDnzNqzH3sabNtzho93+U2PUtgrb4XkEfK6g3vpa+mCjYF+9LurHhONkF52Pfi3zp+yL62Nvg/+1A7wf6gEMfa5562eTA1/w35j7WtPk2B+1+TYld3yZoix8U9LGCeuNr6YsjBfviQ0k3Nhwnu+B87AeRL/1QRB97B/z/MNBHgO506GPNU4WnOvA1/4u5jzVtvsNBu81rtyTbbZO0Xd8haIt3CfpYQb3xtfTFUYJ98dGkGxuOk11wPvYu5Es/GtHH3g3/7wH6GNDHHfpY89T2Zge+JlEZbx9r2ny3g3ZXKLHruwVt8V5BHyuoN76Wvpgk2BefSLqx4TjZBedj70W+9BMRfex98P+TQJ8C+rRDH2veinGaA1+TjLmPNW2+z0G7U0rs+j5BW7xf0McK6o2vpS8mC/bFZ5JubDhOdsH52PuRL/1MRB/7APz/LNCDQJ9z6GPNW4dOd+BrKmPuY02bH3DQ7gFK7PoBQVt8SNDHCuqNr6Uvjhbsi4eTbmw4TnbB+diHkC99OKKP/Tz8/wLQF4G+5NDHmre6bXHgawbG3MeaNn/eQbsHKbHrzwva4iOCPlZQb3wtfTFFsC++nHRjw3GyC87HPoJ86Zcj+thH4f9XgL4K9JhDH2vemnmGA19TFXMfa9r8qIN2Vyux60cFbfFrgj5WUG98LX2RFuyLx5NubDhOdsH52K8hX/p4RB/7BPz/OtCTQN9w6GPNW4nPdOBrBsfcx5o2P+Gg3UOU2PUTgrb4lKCPFdQbX0tf+IJ98XTSjQ3HyS44H/sU8qVPR/Sxz8D/bwJ9C+jbDn2seev7Vge+pibmPta0+RkH7R6qxK6fEbTF7wj6WEG98bX0RUawL76bdGPDcbILzsd+B/nS70b0sc/C/+8BfR/oBw59rPmqxlkOfE1tzH2safOzDtpdp8SunxW0xR8K+lhBvfG19EVWsC+eS7qx4TjZBedjf4h86XMRfezz8P9HQC8A/dihjzVfLTrbga/ZJ+Y+1rT5eQftHqbErp8XtMUXBX2soN74WvoiJ9gXP0m6seE42QXnY19EvvQnEX3sT+H/z4B+DvQLhz7WfBXuHAe+ZnjMfaxp808dtHtfJXb9U0FbfEnQxwrqja+lL+oF++KXSTc2HCe74HzsS8iX/jKij/0V/P8/oF8D/cahjzVf3dzmwNeMiLmPNW3+lYN2j1Ri178StMXfCvpYQb3xtfRFg2Bf/C7pxobjZBecj/0t8qW/i+hjfw///wD0R6A/OfSx5qvG2x34mlEx97Gmzb930O79lNj17wVt8WVBHyuoN76WvmgU7Is/J93YcJzsgvOxLyNf+ueIPvYv8P+vQH8D+rtDH2u+Gn+uA18zOuY+1rT5Lw7avb8Su/6LoC3+Q9DHCuqNr6UvmgT74p9JNzYcJ7vgfOw/kC/9Z0Qf+wr8/xfQv4Fedehjm5Pd3xXEfMuV6QEx97Gmza84aPcYJXb9iqAt/kfQxwrqja+lL5oF++K/STc2HCe74Hzsf5Av/W9EH/sa/P9fcueJRMqdjz0m2f2dVsy3XJkeGHMfa9r8moN2j1Vi168J2mKF4PsIBfXG19IXxwj2RTLlxobjZBecjzU6aH1pMhXNx6bgoBJoANBAhz722GT3d68x33JlelDMfaxps5GxNN+Dldh1StAWBwn6WEG98bX0xbGCPrYq5caG42QXnI8dhPxqVUQfWw0Hg4GGANU49LHHQb0XOPCxh8Tcx5o2VzvwsYcqsetqQVscKuhjBfXG19IXx0k+N5ByY8NxsgvOxw5FfrU2oo+tg4N9gIYBDXfoY6dCvRc68LHjYu5jTZvrHPjYw5TYdZ2gLe4r6GMF9cbX0hdTJfdbpdzYcJzsgvOx+yK/OiKijx0JB6OA9gMa7dDHHg/1XuTAx46PuY81bR7pwMcersSuRwra4v6CPlZQb3wtfXG85H2qlBsbjpNdcD52f+RXD4joY8fAwYFAY4EOcuhjT4B6L3bgYyfE3MeaNo9x4GOPUGLXYwRt8WBBHyuoN76WvjhB0MceknJjw3GyC87HHoz86iERfeyhcDAO6DCg8Q59bAvUe4kDHzsx5j7WtPlQBz72SCV2faigLR4u6GMF9cbX0hctgj52QsqNDcfJLjgfezjyqxMi+tgj4GAi0JFARzn0sdOg3ksd+NijYu5jTZuPcOBjJymx6yMEbXGSoI8V1BtfS19ME/Sxk1NubDhOdsH52EnIr06O6GOPhoMpQGkg36GPPRHqvcyBj50ccx9r2ny0Ax97tJZvSAnaYkbQxwrqja+lL04U9LHZlBsbjpNdcD42g/xqNqKPzcFBPVADUKNDHzsd6u104GOnxNzHmjbnHPjYtJb36QnaYpOgjxXUG19LX0wX9LHNKTc2HCe74HxsE/KrzRF97DFwcCzQcUBTHfrYGVDv5Q58rB9zH2vafIwDH5vR8myRoC0eL+hjBfXG19IXMwR97AkpNzYcJ7vgfOzxyK+eENHHtsDBNKATgaY79LEzod4rHPjYbMx9rGlziwMfm9Nyn0XQFmcI+lhBvfG19MVMQR87M+XGhuNkF5yPnYH86syIPnYWHMwGOglojkMfOwvqvdKBj62PuY81bZ7lwMc2KLHrWYK2OFfQxwrqja+mLwR97LyUGxuOk11wPnYu8qvzIvrY+XCwAGgh0CKHPnY21PtGBz62MeY+1rR5vgMf26TErucL2uJiQR8rqDe+lr6YLehjl6Tc2HCc7ILzsYuRX10S0ccuhYNlQMuBVjj0sSdBvVc58LHNMfexps1LHfjYY5TY9VJBW1wp6GMF9cbX0hcnCfrYVSk3Nhwnu+B87ErkV1dF9LGr4WAN0FqgdQ597Byo92oHPvbYmPtY0+bVDnzscUrserWgLa4X9LGCeuNr6Ys5gj52Q8qNDcfJLjgfux751Q0RfexGODgZ6BSgVoc+di7Ue40DHzs15j7WtHmjAx97vBK73ihoi22CPlZQb3wtfTFX0Me2p9zYcJzsgvOxbcivtkf0sXk4KAB1AG1y6GPnQb3XOvCxJ8Tcx5o25x342BYldp0XtMVTBX2soN74WvpinqCP3ZxyY8NxsgvOx56K/OrmiD72NDg4HWgL0BkOfex8qPc6Bz52Wsx9rGnzaQ587IlK7Po0QVs8U9DHCuqNr6Uv5gv62K0pNzYcJ7vgfOyZyK9ujehjz4KDs4HOAdrm0McugHrf5MDHTo+5jzVtPsuBj52hxK7PErTF7YI+VlBvfC19sUDQx56bcmPDcbILzsduR3713Ig+9jw4eAPQ+UAXOPSxC6He6x342Jkx97Gmzec58LGzlNj1eYK2eKGgjxXUG19LXywU9LEXpdzYcJzsgvOxFyK/elFEH3sxHFwCdCnQZcjH2lQh3M91npw8L0650e2kcJvHCur2OEFenYLyM3ozyOseS3CSHq8lcWO8l6ccAr48Jc/3CkFH56rdVyCPIsR3h7IZI63w3CsbNt50mcklznFJN0ZxJdJb+adgBaOmRKAUCQQ6FVB/eCXJDsCK/cbAgK4ybXLRAVc68ExXCg/Nrtpd4bDdZW9JdCzDdHnJN4p5tYPp4zXCw7t1CoZvZ8BXWhZXOZLFtY5kcW2ILMp+JMyRLE7avcsp7X3gc6YDcyrj7QfMwHe1A18q2N++pAzNeAzs2OjTK1EGfekU5unCf0vJBAdY14VFjOnykn+1I4eIQZeI2e+rHoP5OgeOYW5M1vZKCWTKvi+YiqeDmVvpRi/fhAbqXe2fvmQu2T/XI15+Ngu2kW/0O/Id2frG5kyb35BtaOjIdTQ2NOXyHfW51nxjwc+1ZjPNhcZ0h99UKDTWZ9sbGzqa8+0NHdhp+/lsNpdvbmv36zMNrW3ppny2Nd2Ra8xm0q35bGM+n21qaGjNZvMNTR1NzU2ZTGtHtild39jYnG7IZJszrvrn+qB/+nOmOdbRTPPNgWK9RYsDd4XvzQ6c9VsdDVxvdTirMbJ4iwNZvM2RLN7mcFbjSi/mx3xW40oHFsR8VjPW0axGsL/9BXtnNTT5b3Y0q7lB46zmBsezmhscOIaFe+Cs5sZUPB3MQkdR843KZjU3Cc5qFgjOalz1z01oVlNsUIjzcpRLnK4GmLdrHGDe7niAebuDAWaRowGmUhinpAN7hyAvyWUzycFqkSNn+I4Ig1W5Mr05JTco9Fg2i9Fg5ap/bn4dLcG9M1Csd3GbPdLlJb/YpgfJXTxlv7NZMBJ20fFWhkklMiyX1y0x7w9jMLc4CBLe7ShgerfD5dp3OZLFexzJ4j0Ol2td6cXSmC/XutKBZQqWa29xsFwr2N/+sr3LtTTt8N9SMsGB360uZ9O3OHKItzqcTRvMtzpwDMuVLNfeIhgUvTcVTwez3NEM6739sFwr2T/vE1yuXSY4A3bVP+/bDTNgV4873BYo1u1aHLgrfLc5cNbvdzRwvd/hrMbI4nYHsviAI1l8wOGsxpVerIz5rMaVDqxSsLXexaxGsL/9VXtnNTT5tzma1XxQ46zmg45nNR904BhW74Gzmg+l4ulgVjuKmj+kbFZzh+CsZpXgrMZV/9yxGzahSC5HucTpaoD5sMYB5sOOB5gPOxhg1ijZhCLpwD4iyEty2UxysFrjyBl+pB82odwpuAllWWU8BytX/XMn0z/SewQEN5344wXfI3WXoF83Ot1f75G6y9Eg+tGUQ8AfTcnzvVvQMbtq992pbgEL8e3X90iNV/IeKcmdbdgo7kk5fI/U3YJTV+zVLejXw9bCjwUG9PGUg/dImQ64x4FnusfxjRqpdlc4bHe5GO+N+c0uo5j3OphifcLRdPMTDm92fdyRLO5zJIv7HN7scqUX62N+s8uVDmxQsIXvXge+VLC//Q17b3bRtMN/S8kEB1ifdLkWea8jh/hJh2uRBvMnHTiGjUpudt0rGBR9KhVPB7PR0frUp/rhZpdk/3xa8GbXBsH1Q1f98+ndsIVvvKOZ5v2BYn1GiwN3he9+B876AUcD1wMOZzVGFp9xIIvPOpLFZx3OalzpxSkxn9W40oHWmM9qxjua1Qj2t9+6d1ZDk3+/o1nNgxpnNQ86ntU86MAxtO2Bs5rPpeLpYNocRc2fUzareUhwVtMqOKtx1T8P7YYtfJLLUS5xuhpgHtY4wDzseIB52MEA065kC5+kA/u8IC/JZTPJwardkTP8fD9s4fuC4Ba+DZXxHKxc9c8XXkdLcF8MFOtL3GaPdHnJL7bpQXIXT7m8BDeOOHlvkZWh9B5RVzIsl9cjMe8PYzCPOAgSvuwoYPqyw+XaLzmSxaOOZPGow+VaV3rREfPlWlc6sEnBcu0jDpZrBfvb37R3uZamHf5bSiY48PuKy9n0I44c4lcczqYN5q84cAynKlmufUQwKPpqKp4O5lRHM6yv9sNyrWT/PCa4XLtJcAbsqn8e2w0zYFePO3wtUKzHtThwV/i+5sBZP+Fo4HrC4azGyOJxB7L4uiNZfN3hrMaVXpwW81mNKx04XcHWehezGsH+9k/fO6uhyf+ao1nNkxpnNU86ntU86cAxbNkDZzXfSMXTwWxxFDV/Q9ms5inBWc3pgrMaV/3z1G7YhCK5HOUSp6sB5mmNA8zTjgeYpx0MMGco2YQi6cCeEeQluWwmOVid4cgZPtMPm1C+KbgJZVNlPAcrV/3zTYcrIMuhklVJeR/0LcerYBK+51vMXot0eUlyHPK/JejTvh3z/jDvFPy2g7HwO8J7TKT3N5lVGEmM4wJ+nqxeO1mBOizAKt3n3xXUdSPK/nr33HcdBd7PphwCfjYlz/d7go7PVbu/t4cb2fcdzWalHaykLv0g5oPJftDXkhhNH/9AiZ7vm9RjkyMUYR3pCKthOcCTuR3TR8rayRROLvRPiFfaFcYRCjCOdPRO1KIdX67T/aGYw820G2zDvO7VF/Pf8H8tODZKZo9HoOM1wbG97jk4eB7oR0AvpLrP2yQ96xXsNP85wQH7x8IRNe2bH6O+eR4d/wgdv5Dq2TcvwsFPgH4K9DOmb6SDAsl+PsLzVAR9CcE2T1TS5grBNh/pqM3Sg8VRwnbiCuckr390KF1e8icLyvNFJbc7j/Z04JyiBGdaCU5fCc6MEpxZJThzSnDWK8HZoARnoxKcTUpwNivBeYwSnMcqwXmcEpxTleA8XgnOE5TgbFGCc5oSnCcqwTldCc4ZSnDOVIJzlhKcs5XgPEkJzjlKcM5VgnOeEpzzleBcoATnQiU4FynBuVgJziWOcMb5Xt7SfmpzurzkLxOUX42Sj8wu93TgXKEE50olOFcpwblaCc41SnCuVYJznRKc65Xg3KAE50YlOE9WgvMUJThbleBsU4KzXQnOvBKcBSU4O5Tg3KQE56lKcG5WgvM0JThPV4JzixKcZyjBeaYSnFuV4DxLCc6zleA8RwnObUpwbleC81wlOM9TgvMNSnCerwTnBUpwXqgE50VKcF6sBOclSnBeqgTnZUpwdirBebkSnFcowXmlEpxvVILzKiU4r1aC8xolOK9VgvM6JTjfpATn9UpwvlkJzrcowflWJTjfpgTnDUpw3qgE501KcL5dCc53KMF5sxKc71SC811KcN6iBOe7leB8jxKctyrB+V4lON+nBOdtSnDergTn+5Xg/IASnB9UgvNDSnDeoQTnh5Xg/IgSnHcqwXmXEpwfVYLzbiU471GC82NKcH5cCc57leD8hBKc9ynB+UklOD+lBOenleC8XwnOzyjB+YASnJ9VgvNBJTg/pwTnQ0pwPqwE5+eV4PyCEpxfVILzS0pwPqIE55eV4HxUCc6vKMH5VSU4H1OC82tKcD6uBOcTSnB+XQnOJ5Xg/IYSnE8pwfm0EpzPKMH5TSU4v6UE57eV4PyOEpzfVYLzWSU4v6cE5/eV4PyBEpw/VILzOSU4n1eC80dKcL6gBOePleB8UQnOnyjB+VMlOH+mBOfPleD8hRKcLynB+UslOH+lBOf/KcH5ayU4f6ME52+V4PydEpy/V4LzD0pw/lEJzj8pwfmyEpx/VoLzL0pw/lUJzr8pwfl3JTj/oQTnP5XgfEUJzn8pwflvJThfVYLzP0pw/lcJzteU4PyfEpyGoQacCSU4K5TgTCrBmVKCs1IJzgFKcA5UgnOQEpxVSnBWK8E5WAnOIUpw1ijBOVQJzlolOOuU4NxHCc5hSnAOV4JzXyU4RyjBOVIJzlFKcO6nBOdoJTj3V4LzACU4xyjBeaASnGOV4DxICc6DleA8RAnOQ5XgHKcE52FKcI5XgvNwJTgnKMF5hBKcE5XgPFIJzqOU4JykBOdkJTiPVoJzihKcaSU4fSU4M0pwZpXgzCnBWa8EZ4MSnI1KcDYpwdmsBOcxSnAeqwTncUpwTlWC83glOE9QgrNFCc5pSnCeqATndCU4ZyjBOVMJzllKcM5WgvMkJTjnKME5VwnOeUpwzleCc4ESnAuV4FykBOdiJTiXKMG5VAnOZUpwLleCc4USnCuV4FylBOdqJTjXKMG5VgnOdUpwrleCc4MSnBuV4DxZCc5TlOBsVYKzTQnOdiU480pwFpTg7FCCc5MSnKcqwblZCc7TlOA8XQnOLUpwnqEE55lKcG5VgvMsJTjPVoLzHCU4tynBuV0JznOV4DxPCc43KMF5vhKcFyjBeaESnBcpwXmxEpyXKMF5qRKclynB2akE5+VKcF6hBOeVSnC+UQnOq5TgvFoJzmuU4LxWCc7rlOB8kxKc1yvB+WYlON+iBOdbleB8mxKcNyjBeaMSnDcpwfl2JTjfoQTnzUpwvlMJzncpwXmLEpzvVoLzPUpw3qoE53uV4HyfEpy3KcF5uxKc71eC8wNKcH5QCc4PKcF5hxKcH1aC8yNKcN6pBOddSnB+VAnOu5XgvEcJzo8pwflxJTjvVYLzE0pw3qcE5yeV4PyUEpyfVoLzfiU4P6ME5wNKcH5WCc4HleD8nBKcDynB+bASnJ9XgvMLSnB+UQnOLynB+YgSnF9WgvNRJTi/ogTnV5XgfEwJzq8pwfm4EpxPKMH5dSU4n1SC8xtKcD6lBOfTSnA+owTnN5Xg/JYSnN9WgvM7SnB+VwnOZ5Xg/J4SnN9XgvMHSnD+UAnO55TgfF4Jzh8pwfmCEpw/VoLzRSU4f6IE50+V4PyZEpw/V4LzF0pwvqQE5y+V4PyVEpz/pwTnr5Xg/I0SnL9VgvN3SnD+XgnOPyjB+UclOP+kBOfLSnD+WQnOvyjB+VclOP+mBOffleD8hxKc/1SC8xUlOP+lBOe/leB8VQnO/yjB+V8lOF9TgvN/SnB6FTpwJpTgrFCCM6kEZ0oJzkolOAcowTlQCc5BSnBWKcFZrQTnYCU4hyjBWaME51AlOGuV4KxTgnMfJTiHKcE5XAnOfZXgHKEE50glOEcpwbmfEpyjleDcXwnOA5TgHKME54FKcI5VgvMgJTgPVoLzECU4D1WCc5wSnIcpwTleCc7DleCcoATnEUpwTlSC80glOI9SgnOSEpyTleA8WgnOKUpwppXg9JXgzCjBmVWCM6cEZ70SnA1KcDYqwdmkBGezEpzHKMF5rBKcxynBOVUJzuOV4DxBCc4WJTinKcF5ohKc05XgnKEE50wlOGcpwTlbCc6TlOCcowTnXCU45ynBOV8JzgVKcC5UgnOREpyLleBcogTnUiU4lynBuVwJzhVKcK5UgnOVEpyrleBcowTnWiU41ynBuV4Jzg1KcG5UgvNkJThPUYKzVQnONiU425XgzCvBWVCCs0MJzk1KcJ6qBOdmJThPU4LzdCU4tyjBeYYSnGcqwblVCc6zlOA8WwnOc5Tg3KYE53YlOM9VgvM8JTjfoATn+UpwXqAE54VKcF6kBOfFSnBeogTnpUpwXqYEZ6cSnJcrwXmFEpxXKsH5RiU4r1KC82olOK9RgvNaJTivU4LzTUpwXq8E55uV4HyLEpxvVYLzbUpw3qAE541KcN6kBOfbleB8hxKcNyvB+U4lON+lBOctSnC+WwnO9yjBeasSnO9VgvN9SnDepgTn7Upwvl8Jzg8owflBJTg/pATnHUpwflgJzo8owXmnEpx3KcH5USU471aC8x4lOD+mBOfHleC8VwnOTyjBeZ8SnJ9UgvNTSnB+WgnO+5Xg/IwSnA8owflZJTgfVILzc0pwPqQE58NKcH5eCc4vKMH5RSU4v6QE5yNKcH5ZCc5HleD8ihKcX1WC8zElOL+mBOfjSnA+oQTn15XgfFIJzm8owfmUEpxPK8H5jBKc31SC81tKcH5bCc7vKMH5XSU4n1WC83tKcH5fCc4fKMH5QyU4n1OC83klOH+kBOcLSnD+WAnOF5Xg/IkSnD9VgvNnSnD+XAnOXyjB+ZISnL9UgvNXSnD+nyOcFQRnNt2QyxUaMwU/67emM81tTfXpXH1bQ5Pf5Nc31eczTdlsoSnX1Njc1tyYbvZz2YLfUd+c7Qh4TxBs86/7qc3p8pL/mwo5+Q1N6ujnlKD8fqtEtysF2/w7JW0eINjm3ytp80DBNv9BSZsHCbb5j0raXCXY5j8paXO1YJtfVtLmwYJt/rOSNg8RbPNflLS5RrDNf1XS5qGCbf6bkjbXCrb570raXCfY5n8oafM+gm3+p5I2DxNs8ytK2jxcsM3/UtLmfQXb/G8lbR4h2OZXlbR5pGCb/6OkzaME2/xfJW3eT7DNrylp82jBNv9PSZv3F2yzp2St9wDBNieUtHmMYJsrlLT5QME2J5W0eaxgm1NK2nyQYJsrlbT5YME2D1DS5kME2zxQSZsPFWzzICVtHifY5iolbT5MsM3VSto8XrDNg5W0+XDBNg8RbDOw2rHH55dBg48Amgh0JNBRQJOAJgMdDTTF1AfkA2WMTIByQPVADUCNQE1AzUDHAB0LdBzQVKDjgU4IZDAN6ESg6UAzgGYCzQKaDXQS0ByguUDzgOYDLQBaCLQIaDHQEqClQMuAlgOtAFoJtApoNdAaoLVA64DWA20A2gh0MtApQK1AbUDtQHmgAlAH0CagU4E2A50GdDrQFqAzgM4E2gp0FtDZQOcAbQPaDnQu0HlAbwA6H+gCoAuBLgK6GOgSoEuBLgPqBLoc6AqgK4HeCHQV0NVA1wBdC3Qd0JuArgd6M9BbgN4K9DagG4BuBLoJ6O1A7wC6GeidQO8CugXo3UDvAboV6L1A7wO6Deh2oPcDfQDog0AfAroD6MNAHwG6E+guoI8C3Q10D9DHgD4OdC/QJ4DuA/ok0KeAPg10P9BngB4A+izQg0CfA3oI6GGgzwN9AeiLQF8CegToy0CPAn0F6KtAjwF9DehxoCeAvg70JNA3gJ4CehroGaBvAn0L6NtA3wH6LtCzQN8D+j7QD4B+CPQc0PNAPwJ6AejHQC8C/QTop0A/A/o50C+AXgL6JdCvgP4P6NdAvwH6LdDvgH4P9AegPwL9CehloD8D/QXor0B/A/o70D+A/gn0CtC/gP4N9CrQf4D+C/Qa0P+AjLElgCqAkkApoEqgAUADgQYBVQFVAw0GGgJUAzQUqBaoDmgfoGFAw4H2BRoBNBJoFNB+QKOB9gc6AGgM0IFAY4EOAjoY6BCgQ4HGAR0GNB7ocKAJQEcATQQ6EugooElAk4GOBpoClAbygTJAWaAcUD1QA1AjUBNQM9AxQMcCHQc0Feh4oBOAWoCmAZ0INB1oBtBMoFlAs4FOApoDNBdoHtB8oAVAC4EWAS0GWgK0FGgZ0HKgFUArgVYBrQZaA7QWaB3QeqANQBuBTgY6BagVqA2oHSgPVADqANoEdCrQZqDTgE4H2gJ0BtCZQFuBzgI6G+gcoG1A24HOBToP6A1A5wNdAHQh0EVAFwNdAnQp0GVAnUCXA10BdCXQG4GuAroa6Bqga4GuA3oT0PVAbwZ6C9Bbgd4GdAPQjUA3Ab0d6B1ANwO9E+hdQLcAvRvoPUC3Ar0X6H1AtwHdDvR+oA8AfRDoQ0B3AH0Y6CNAdwLdBfRRoLuB7gH6GNDHge4F+gTQfUCfBPoU0KeB7gf6DNADQJ8FehDoc0APAT0M9HmgLwB9EehLQI8AfRnoUaCvAH0V6DGgrwE9DvQE0NeBngT6BtBTQE8DPQP0TaBvAX0b6DtA3wV6Fuh7QN8H+gHQD4GeA3oe6EdALwD9GOhFoJ8A/RToZ0A/B/oF0EtAvwT6FdD/Af0a6DdAvwX6HdDvgf4A9EegPwG9DPRnoL8A/RXob0B/B/oH0D+BXgH6F9C/gV4F+g/Qf4FeA/ofkAksEkAVQEmgFFAl0ACggUCDgKqAqoEGAw0BqgEaClQLVAe0D9AwoOFA+wKNABoJNApoP6DRQPsDHQA0BuhAoLFABwEdDHQI0KFA44AOAxoPdDjQBKAjgCYCHQl0FNAkoMlARwNNAUoD+UAZoCxQDqgeqAGoEagJqBnoGKBjgY4Dmgp0PNAJZm0UaBrQiUDTgWYAzQSaBTQb6CSgOUBzgeYBzQdaALQQaBHQYqAlQEuBlgEtB1oBtBJoFdBqoDVAa4HWAa0H2gC0EehkoFOAWoHagNqB8kAFoA6gTUCnAm0GMt+rN9+CN99ZN98wN98HN9/eNt+1Nt+MNt9jNt86Nt8RNt/oNd+/Nd+WNd9tNd9ENd8bNd/yNN/JNN+gNN93NN9O7AQy3/wz39Mz36oz34Ez31gz3y8z3wYz390y37Qy34sy32Iy3zky3xAy3+cx374x35Ux32wx30Mx3xox3/Ew38gw358w33Yw300w3yQw7/s379I376k374A371c37y5/P5B557Z5n7V5V7R5D7N5x7F5f7B5N6957615p6x5X6t5F6p5z6h5h6d5P6Z596R5r6N5Z6J5H6F51595j555R515/5t5t5p5b5l5J5h535Z5l5V5T5R5B5N5v5F5d9AjQOadN+Z9MuZdLeY9KOYdI+b9HebdGOa9E+adDuZ9CeZdBOY5f/MMvXk+3Tz7bZ6rNs8sm+eBzbO25jlW84yoef7SPNtonhs0z+SZ593Ms2TmOS3zDJR5vsg8u/NTIPPMiXmewzwrYZ5DMLGv2T9v9qabvdpmH7TZy2v2tpq9nmbvo9kLaPbGmb1iZu+U2Utk9taYvSZm74XZi2DuzZt71eberbmXae7tmXtd5t6PuRdi7g2YtXKzdmzWUs3aollrM2tPZi3GrE2YubqZu5q5nJnbmFi/YmfY4Jm9yiYd4XWnwKUYtjvyzd5es9fV7P00eyHN3kCzV87sHTN7qczeIrPXxuw9MXsxzN4Ec6/e3Ls293LNvU1zr8/c+zL3gsy9EXOvwKydm7Vks7Zq1hrN2tvBQIcAHQpk5u5mLmvmdmauM8HrnXx0XBP8jnhp2uizn7xzJi5XG5JXF/xOufrySz92QtMcnGdiFpMumjE1+/Yf3n0ZzssFebd/dOxnDnipYi3OawjJOz4kryUkb3pI3syQvAUheYtC8paH5K0MyVsbkrc+JC8fktcRkrc5JO/0kLxtIXnnhuRdGJJ3cUje1SF514bk3RCSd1NI3s0hee8Kybs9JO8DIXkfCcm7KyTvYyF594bkPRCS92BI3sMheV8IyXssJO/xkLynQvKeCcn7TpD30GMXvfqB5x45Hec9F+Q93PTY3B/eWTsS5z0f5D299NZnVw57Qx3O+1FI3gtF8qqD368O3flbFfyvCH7NZWasaAn+p8tLfhXiK82/Kd3QVOX1TML4s1WIpwP+Gcs/5Yb/jmc8TOro7MnfI/XWBP8TSJb2GptXgfI2BXmDvO6x2hzbMbyK8HPR7xiTtNyGM/grUNtMmt7ZLQ+ZenN5y3tGp5N2ZSz/meVj9+kJy3uWG+xdvmR2+djTxbCf5AZ71vKf44Z/zvKfi/gnHOCf54Z/l17OdyOfDst/AeLvQn8WusHfxX+RG/xdtrU44O+C95JOF7qT6ZLNUif8G7rwL3PDv8u2lrvh3+UbVrjhX2/5r3TDv8HyX+WGf6Plv9oN/2bLf40b/u2W/1o3/LtiknVu+Bcs//Vu+Hf5/g1O+Dd2+Z+Nbvh3jY0nu+Hf5X9OccO/y/+0uuHf5R/a3PDvst92N/zbLP+8G/5d9lsI+Hu7zjtLT5h1YzPveyngx82X5dpSn7Zz0VR3U7piIVt3JTovF4P5rQlSn0fa6ZH6qz2nc3s/QeqzeKh87LzVym4Ag7WOyaN9OICpZwBTTx2TR2OPcnhtFOS1UpDXekFekm1cK8hrtSCvdYK8VgnyWiLIS7KNkvp1iiAvSduWlP1yQV6Sen+yIK9lgrwk9atVkFdcxw4bb7qNO3au/RieA93wz4bJArfJ1l+DMHgon/v1PD5GsnVVe71jDRcxEtc2jL9YP1MZlKMzmFcVk+eiTytD2k3rL1aeiyVt+UEh/HH5Wq+3Dg8isqhyI4tMWL8NQnXa+oeg8/lC27mb5m/d5JFEY2Mrt9GknF0PrvB6y3tgEV4e+T+anEsifjgNQW3YdsGZ7Qu3bi9s8/pIYcbs9uak3xzVWdj6+8tZpAieYkptZVfJYK3zehsUXUDgjK2SqYfjlRfktUSQ1wZBXisEea0T5LVckNdqQV6SbVwlyCuu+rVUkNdGQV6nCPKS1C9Jea0R5CWpX5I2tF6Ql6ROSPpVO5l1PAlqoIuXONk8HFwmSB4OVKej9tOUJP9xmwyP3yK+tBzFg+MmHOwVixlMcjwx8KuIPIT5d008Bno9ZUrbNKiIrGw+92t50TxbV38tuHNt4yZJdV5vvaQTLo7XwBJ57c4FAk7Ha0Kwcu2gE+ywSSuWiS0/KAQXLr+nTEL3I+XshrxyJqH7kXPFJqHlLg5ZnCbVMbzshJrOTU1qCX7TZaX2LB3LBHlnHPv3Rmp7ONGxEMvW5mH9p2NoNeJlx1CbNxhdV0muGxLCsyaE59AQnLUhPOtQHp2r74PysO+iiYsDbJ8Z+f0b8aXlbDIysfJMdXo92tISnE+XkRqb0mlbXzLgX+n1xo7rryTlfxP8ryb4rXxadhFnR2Or35Ft7Witb83nc+2twwh/kyqQnPAmgt13k3+nn6Y4Nd3kH+J12+KWra356a1nbTt3S6GCiLLY0JEg7Gizqal0qR85R4eQCnKdHZI4VaU4EwwPTgSWZ63XEwO+Nkn+0+GFnqtgyici8LLHyRAsxXgkCI+aEB7UdGzbBzP8rOnUEP4twf90ealA3TZOnNumrrmO4PK86K4ZP4NSyhQND010SLHXW5dK5ToE5ePyA4OKzHCRH9izvmEMniguxyQaFmGXSofc4YL1DEdlBpB69hWsZ19Uhk4lRgjWMwKVodPQkYL1jERlbBhg7XMUyrNttfY5GuUJ3m5ptW3c3+udbN4BqG6qU2NQHg5faeLs07apVPvcD+VhbJgntk8s1/1QPi5/aKIby741Peun0xw8XbPPRiS93v00yuvdllEezxtfW0P+23yTrD7sj84L6kM6il7j+qs9l/rZHersT/BQ+ZQY6mCxY/a1hJ0tg8viVIsg4fKV5D9VBftIU5RQp8rrrcaCIm53q1LpZsv/ADf8Gyz/MW74t1r+B7rh32j5j3XDP2/5H+SGf5vlf7Ab/l2P9R7ihn+9HQqsT1iLQjX7mg869FgcJrkdotNtUV2yrb/a6+3jXLjk0QQPlQ8N5Q9lsNaRPJNmd3aXo3lJ5lzFXl57ee1mXjaExz6AxhicvYwOqScsNByMrrOPL9PpK8bHrazSvKEhebVMu+gU3aSF5Lp9GJ7Gr34o0c2vWB9g2dBlHCwb7FcMjeuD1wzCC18/jvA6rA9eJxFe+PrDCK/xffCaQ3jh68cTXoeH8MJjZS1z/eGE14Q+eB1AeOHrJxBeR/TB60DCC19/BOE1sQ9eBxNe+PqJhNeRffDan/DC1x9JeB3VB68xhBe+/ijCa1IfvA4ivPD19lrLa7LXncKmo5YXvn4y4XV0H7zGEl74enttDcMrMPuumGkKOr87YiZbfzXBKoynK2aa4vWWK5YPjZnSDNY6Jo/6mjRTT5qph+M1XpDX4YK8JgjyOkKQ10RBXkcK8jpKkNckQV7WV1gfgHVX8tZD1LHS1h82Via93vo8nuBOMu3h6h7P1G15cGM/9kk4z2PqNInK/ugi9fUlG5PsOlVtSNu42JdiLjX2xdeHxb721TfcrRsap+JbXIeSPLyrYBzJq2Xaxd2eGk/y8K4CKzcc+1aS9tjXK1YR/MJ2kaZ33TlZ7YZ1jkKC1Od5u3edw8piXIgs3PiunB9VFocRWYxzJIswf8Gt+djy3NxiHFMeL9tvKmyfv3XTiRcsb92ENyxhU6Fwakg5eufk0CKwWki5w8h/a9IUB+aFE8WRJP9p+ZY+yuPjIcx5k7hpGV164LoNnwtberDlrMpPIHhbgv/p8lLXJuSJbvh3bVjlpqi4Tbb+GkZOiSK/lhfNs3VVe737yIV5cm0L62ccBkeZyh9RIq8qJs9Fn04IaTeuvyYEK9eOIaQdVEYtIu1obOTkJMe/+82oE53wz3XdgjvSjXzqaag0I1A+E049kejZtzg8TJD+wz5UTg+zDVH9ga2/2us9nrnwB0MIHiofutxQw2CtY/KoHtUw9dQw9dQxefSBqF3lxelfObjWCeEyabkgryWCvCTbKNWPnnAblwnykmzjWkFeGwR5rRHktUKQ1ymCvFYL8pLUCUl7lLQhSZ2QlNcqQV4nC/KSlP1KQV6Sst8oyEtSXpK+cKkgL0l5xdUXSspL0ufsCTGTpE5IjttSsjfHdP4dF72Xkr05pmsAcdF7Sf2S9BOSMYCkvNoFeeUJr6jzelu+linPrQvatWR8O8xea9dQ8C0vwTWLTJic8C04W/+uPAxv5VZPytntZRVeb3scWoSXR/7Xk3NJj38Ynnsab2ARnLZe2r8WL5XZAKY85kefSjsx6Hgjx1HBSe5lDEMQ/+VBhtUHujWgJfifLivlsjUBv8led7KytHW72a6TjfzAr62/mmAVto2u9TxuWxaWD13Pm8JgrWPyaB9y25SmMPXUMXk0pimH11pBXhsEea0R5LVCkNcpgrxWC/KS1Il1gryWCPKS1AlJea0S5CUpr5WCvKTkZY7pPYS46OpyQV6v9340aaMgL0l5SY5DSwV5ScorruOQpLwk/b2kfkn6HEl7lNQJyZhJSvbmmK5PxUXvpWRvjun6VFz0XlK/JP1EXOOvdkFe+YBXbZCH55P0ERDukadJIfXg6ydF4MXNh235NFM+bB0M67291q49+CjPxToYN9fHj1HY+ndlHczKzSfl6DoYXl+ZUoSXR/775FyxdTC6p+vBQPhWvo72SrLb3+mjDHjtjO6lxetwYWuv3F7awUV44Rf04a8F47fZ4PJfROt2+9f05NnXFm3bx1xb6V7Xw4vUn/C6da6SlP0KwnZggK3G6y0nK3/H/d2eIPVZueBzuP7+2pvH9ROnR9w6qyCetih+GeOl67Kcj7d+A7+FCZefhNpI/Qz2e5Xk3LcDodR5vX397M6eGCYz7eHGBrOm/Y2Knm3b1T3fmC83ftn+tfXgR4mt3Rs836/o2RbqJ/C15vgglI/L/2dIN8/nAp61zPW0/6gtYl9k0ozOnuVtf9r7D7QM9WO2/IvIVxxM/Bj3Jq+DQjBbnvilmxizfU0CxfALMu44WsNnxx1bVy3BS/uHtoXrE6p3RzFyqGGuo37YkZ+J7Idt/f31ZrGwR/CxXB3rR1sUv4Xx2r48msmzvGzMhm0Il5+M2ojL42N7PT73N+KHsc+mfpiLY7lH3o3v+CPxUbg9o0nbSp1H4OupDPF15fp7DnOY3e1qPZgXjhlxvxbznfgePu4P7DuxHlLf2aVDAVDjv8eFxHp4bEsm+8Y6mMFaScr/BI1tAwKeVm9q0fW2P7j+qSV5o5l6E6Ssh3DiMnQ8sjgHFClfW6RdNUimo8iYiGXB9WttEQwppl0m0X615ffZhX4dnuwbKzfXqCTlH0X9OpL0K5ZfWL/WkTzcr1ZG3JhL+7zUMRdfPzqknhEkD+uOfUNsDflv802yYxEe4+XGovbIjx/b+qsJVldjNffqHSyf/pkztaejjEEYr+PYIcvt9yj2+g9sj7g8nZPhtSa8blZJzmUCxeDiEctfMk7ob15h66LUz08gssD6mijya/nSc2HxPPURLuIXk6x/t35qMoOBjjW2HnqO1oOvt+U4OzHUEvxPl5WyaW7fmCB/n3utlSD/rg/FpJ3wz3W98oKu4eK+yaDzcj6sPvIztLb+aoLV1ZiTIXiofOieuyyDtY7Jo32YZerJMvXUMXn03ldceK0Q5LVWkNcGQV6S8lotyGudIK9VgryWCPKSbON6QV5xtSFJ2S8X5CWp9ycL8lomyEtSv1oFeUnq10ZBXm2CvCT1XrIfJf2XZBvbhXiZYxrLl4Mr3ynHS1JekvHEnjAOSep9XOOvpYK81gjy2ht/7T69l4xN9o5ppfGKaywXV18oGctJ+kLJfpSUV1zjL7rW+XqMv1YK8pK0bUkbkpSX5DgkaUNxlb2k/1olyCuua0OS+iUZ+8Y1xozr2EHvY0mMHdw9VPzebbf3mdJZyz/niH+YrHCbbP32vlEalU8U+bW8aJ6tq5rwEm6bH9Y2jD9Mp7AMytVPy6uKyXPRp5mQduP6S70XKGVn5ni0IK8awovbC8HdC7Xlc0x5Tk9qmbrttbZv61GeYN9mwvoW+whb/648b2XltoKUs5+Pq/B620a2CC+P/F9BziU9/nkr7pm2uiI4bb30XNh+tykh9Ywss56REevR3B7K2+6z4j7L6HafSX2H230mDRnuGUo5/rl6LoaQ49/YxI03gvJps+NHjugG7ns3/rAhGzXmsPVXe719pYuYo57gofKh+3AaGKx1TB7VwQamngamHo5XRoiXSfSeUjm8VgjyWibI6xRBXpJtXC7Ia4kgL0mdWCrIS0onOJ+6VyfCea0T5LVekFdcbVtS9pLyWinIS7KNawR5SfajpN6vEuQlpffmmL5rJy460S7IS0onzPHe+Gv36KrnxXOsNcd0jrzXF4bzygvykvI55jjtyfE6UoiXSZI2JOmjJce0uMaFcR3TlgryiqO/l7YhSXlJ+ei9Y8frY+wwSXJuJekLNwry2rumsPtsSFL2km1sE+QV1/mQpOxXC/KK63qhZJyz10/svnhir5/YfbKPq5/IE17c3p86dG5WUN7uccD3Qul9mPo+eM0gvPD19V7fbcS8TiK88PUN5LrGIvXg99xgPWhk6ub4Wx5VzHlDLcH/dFkpV6hi2iHHv7HV8m9ywj+Tt/fbm5FcE8GvrfsYdF5ub0Au8jslbf3VBKssnu69CscQPFQ+dK/CsQzWOiaP6uCxTD3HMvXUMXl0vC2H1ymCvFYI8loixMsc03sx5eBaKoTLpJMFeUnJyxNuo2Q/Uj8bF13dKMhL0rYldWKdIK+9/muv/3LZRkm9XybIS0rvzTFdw4+LbcfVHiV9dFzHWsl+XC7Ia08Yh/aENkrikvSrcR236bw9LvolJS9zTPdtlYNrtRAuk6RiE5PiOqbttcfd18a4jtt7wjxN0kenPRleJsVV7zcI8orrWkerIC8XPpo+l2lSS/CbLitlc3YtGj8HnfB61ovXnwXXzQsJUp+VET6H66/2escNLtbxuftUWD4VRD6NbvDkE4Q/xtPIyMf2ZROTZ3nZ+wz4Phku34jaiMvjY3s9PndL5c7fOoYn9ZNNTHvwOStf822FmwK+JdhApr3Dz9YXGuvTDa25+nxDNpPPNKbzufoO32/yM825pmy2oz3XlG/KZDsyjZl2+uyoxYrrddTHuag2YOuv9pzapB+mc9z9aE7n7LVUF0xa3NldrhRdkNQrDpf9JlLYe1nc6kK2bVd1Ie0ET7gupBm5lqIL5ngiOi63/2hMXQ6v1YK81gjyWiHIa7kgryWCvE4R5LVekJdkG5cJ8pJs41pBXhuEeJljer8iLvolaY+S+iXpCyVxrRPkJan3r3edMMf0Hmlc9OtkIV7SbZTU+5WCvCT1fqMgr71+4vUxdki2sU2Ql1Q8YVJcZd8uyGuvDZU2dtDnBPbakE7ZS87dJefI+YCXXUOaiPJagt90WSnb9f7DI8V5d78/eUr5vPP0BF1XE8Sd456DkFsjy6W5Zx0Scvi7+B8rL5uu930eJ88709d34ycM6CmvqUGZYt+NPwzl4/I3DOzmeWTA07ZrqJM+yeWifKN9FDovp2+ZdILU53n8GrGtv7++0T6K4KHyoWvEoxmsdUwe7cPRTD2jmXrqmDw6NpTD62RBXssEea0X5NUqyGuFIK+NMcW1XJDXEkFeS2OK6xRBXpJ6L4lLUvZrBHlJ9qOk7FcK8pJsY7sQL3NMv41aDq58pxwvSXmtE+QVV9uWHDtsPGGffcfx41FezzysS5NIffujPMzfxqVjUL5kHGj5j3XDv+tbLAd6vWWM22Trt3HmAah8osiv5UXzbF3VhJe07MLahvFT/TkQ4cEyKMbrwBJ5VTF5Lvp0TEi7cf01IVi5duxPZMLVw81RbPmDQnDh8tYuse7ba60MD0Z5gjLMhPX3QahOW/+ufMfGyu0gUm5WZ7ccqOzHFuHlkf8HkXNJxA8nK2M8jx1FeI0kbSjWv3XM9bZclLm9Gz+QjfwNDlt/f83tD4goVyu7MQzWOiaPzu05+xzD1FPH5NG5fTm8ThbktUyQ13pBXq2CvFYI8toYU1zLBXktEeTVLsTLHNN5STm48p1yvCTltU6Ql6Q9niLIS1LvJX2hZD+uFOQl2Y+S/ktSXhsEeS0V5CUpL0kbkownJOW1RpDXXr+6+/yqlOzN8QRPhpdJknovJXtzTPd2xkXvJfVL0k+sEuQV13j1aE+Gl0n5zp2/buf46Uxc19Tw92YTRX4tL5pn66omvITb5oe1DeMP0xksg3L1z/JyvLbe1acHhLQb11/qOkyUddKoMhlCeA1heIWtuUbt21qvd3/aax3bWNea6/5ecTnh+ndlzdXKLUPKzejslgPtuwOK8PLIf/qsf19rrrhPR5A8rH91pJ6hpH192Sm+fmhIPfuVWc9+EevR3J6+9t+NHMjXWWz/3WiUj8sX0P670QN7thFfP8zrmYd1ajjJq0F5+5I8LDdbztp7LcqTs3c/bWVp+xMnm7cPqnswyRuG8nC7aUqS/7hNxn/8FvGl5SgeLEOMDfPEfc3JtZKUP2JgN5bDa3ieCcQT47T3imx5K8sBXne7cRmKwZafhDAcXMPzTBVpV20RntORDk8ZyPP0PN4Wabv2Ie0q5lMqSfksatcoJDhcxv7HY6p9n4KtaxhTl1fkHNWNYUXySq0Xy8eeGx6h3gSTR3WJyhNfX0zmVJds+akhulTDYMDyoP0+lGCgZfYhGGz5aQwGI2frQ9q3nnXB9Naztp27peCRlELH1NVzXU27oIbhUyxZMZjmWXOhfOz/MDXhzNErcq5Ytw9B5/OFLYXthSICqiDMBheprMLjE/Wl9jqT3I45O2NMXJ/n8XMvW3+1x+ttiwwen/p5i4fKh94LrmOwlhof4TZR/xIlPgrzHUMjtmeI163Y27ZvPaeYzuExnNO5IUXqTzDXe+TaBHPOJGOUywOjrCL1CutB17uShjAYudgjQfJwe6muUFvCeVhXUiQPjxeVJA+PLQNI3nCUN5Dk7YvyBpG8ESiviuThvRjV6JgmLtazfWbq+zfiS8vZZNqTD4Cba19vcxjKq8LrPTcxyX43yOq+m/0w7WmLx865i8XPI1E+Ln8WGusnkniD27s0ipEXxYDL43bTvsI6S9d7uLq5GNft2mi3fMcg+XFtOwDl4/Lnh8iXWzsLk29f66cWj5UvlukYwqsv+c7o3Pkbd/l27kb5cuuc3J5A6u9K3RNYF4IB17NfmfXsx9QTxquO4YXnCRAIbz6vcM7Crdu7XqtpWWKxeuS4ipwbQv7T0HdEEajFQmv7f3/yn95uOJT834fBxyWLAyeKJen1nayqW1m9Ban6JKLq3NCG67Tuki7B4WvxEpxVr+NROarGxzN14nNhamzLcfXQRwtOYK5LkDyM4YQQDPh6W866uBaUJ+ficl0ublrAr9hyZgvKx+VvDXFx9hrc/nFM+ykGXL4FlbF4ONnba2uYuhNFfk1KMudov7SgMuODY9f1HB4c1zJ5VNdbSD30XJiut/RTe+r6qZ7afqqnpp/qobcnpgnWMw2VsbcrrL6diPKoXzuR1EPPhfm1E0l7jhdsD+enaxh85daDZUMfJ5uO8vAYZ3HMYHBYHz8TnRdcgoj8ymRbfzXBKoyna2lsJsFD5UOXO2YxWOuYvOPQMc7D9cxi6uF4jRfkZXWj1uutKzNIPdOZeqaH1DODqcfq1UkoTzB2aLb9MsfrnWzeXHSu0NmNgyZuecfiNrHFlJpuvrQcrRPLdS7JwzY2j+ThvppP8majvAXBca3XW764bpxn20jP0X7E159EMODryvVhHGZOL2eS9pSqlzOZemqY68ptD4eZ9rlEPbg9s0g9swTrwbo4m9QzFV2Htyj8ntyKtdfhmB5fa5cBK0n5e4Z08/wTWSafi3AJ+pI227Z5Xu9k8+ajuqltLEB5VM8WojyqG4tQHpY5TZx/srIw/mlxCf5pDsqzbbJ9YNcH/odusb86sOf1uA/pa/jx+Dmb5M1m8gz/P1R348FywNsC8PoE1RtbfnSw7u923Glo5MYWGkvNc1R3FHvmxhaMx+KuZvJSZWDtaG9KZ9MNDflCQ66tPteR8HrbVJI5R+fh85nyOaa8lfUCN7LOWFtKdnbzx+OySSmUN4/kVaI8i9Go6OaanvjnO8IfRf64/jqm/EmoDaX0pUte2B9I8Bq6i7yGeb3HJOtzHMe+rZwPsomzeZ/kYZ3LkjxsT/UkD49l+LYxTX3F09tLGK/wuDivCE87FuC5gB1jKknZicE4Ycaewwf1rAvHhHM7e+bh2MvWY3i0DOo+j+vB+3TsOGnSoiK4ppLxy1Gsk+diHTp+zXdUd9Txi85/MB6Lu5rJK2f8avM7soV0W1su05avb2hoCBuP8Dk6fi1gyjcz5a2sF7qRdRs3fi1AcjUphfLo2IbHL4uRG7/cjL+5tijyx/XXMeUXojaU0pfWt3NxEzfPP4bk4TkfjnVbiI27iRNz7dRucOL8PB0fsE7S8QHPWej4sBjllTo+WFmUOj5gP4nbhHmm0DnOx1eS8ovQGLGAjBF4TLd1m3KPk3LzGdxubSb6Wqutn/OhLtZaOZ/I2R2nf9S+cR7+tBvOw/UsZOrheI0W5GX1otbrraPzST1zmXrmhtQzn6nH6hW2P7l+rPdtvyzxeiebtxSdK3R246CJs32Lu9S1VizXpSQP29gykof7ajnJw/5tRXBc6/WWL64b59k20nO0H/H1iwkGfF2iyK+th56j9XCYOb2kvrNUvVzA1BO2VrKr7eEw0z6XqAe3ZyGpZ6FgPVgXF5F6cIyO11ovInMOex1ea+Xm3pWk/DvQWuulJDbBdrC7fAlnG8tQHtWz5SiP6sYKlIdlThPnn6wsSl1rxb4atwljjxqb2PJvJv3kKJZIDyPt4mQatgYatxjHzXw6PMbh/GWpMc6R6Jj6nlLjkpmCvKxu13pe0bgkQfJwPfND6uHipT01xuF8SH/FODRWLTXGwdf3V4wTppc0xilVLxcw9YTN93a1PRzmPS3GeVAoxrkExTgP98v6i2yMQ/XMVYyD119KiXHC5mB9rZUkSN3FYqF5nTt/6TrNU2id5slBxXGdhOqeUdWz3N51mj13ncbqBbeXio59pe6l4vaL7KkxDJZrf8cwuG6cZ9tIz4XtVeuvGCZML2kMU6peLmDqqWGuK7c9HOY9LYZ5RSiG6UAxzKsK12monmlap8H386PEJl2+Pogz4rBOw+11dbtHJXqMY+uvJlhdxTicv+T2EHPjk72W8z10nYaLpRYw9XC8ZgryovNhbk90guThemaG1MPte3a8r6GDjv84ceNyqTEO3utQSoyD5Up9IbaxJSSv1PWdWq+3fMtd18PX99cYOpO0B2OgMVupenkSU08Nc1257eEwu46ldte6U7EYp76q+xp8XdQYx5ZfhGKcJjJ2OtonU5Iv4WxjCcqjeobjCKob3PpOVP+0q+s02FdT/4TXSmw5bq2Esx3HcUQhii5zcYSj5xlD4wjOJxm1tp/X2lTYvvjcti2b2+cVLtg27cz84tZztm9u3TItnz+nsG0bbg3VGtpaqi20jD32mfOYx7w+WjGrc+cvNxOdR3jN74PXDMKL24VOvUgxXicRXpznoiMfZ200msLlMZ6FfeCZ01kcz0LCa1EIL3N8iNeTFzfztLwW98HrAMILX7+YXLekSD24DPaGS5i6Of5Ub5f2gflAghnjorOzZX3wOpjwwtcvI7yW98Frf8ILX7+cXLeiSD24DJ4Fr0B1J5hzHJ4xIXhWEF4r++B1EOGFr19JeK3qg9cowgtfv4pct7pIPbjMKnR+Nao7wZzj8IwNwWOvjTLCYayCI0rkXfG2/v4a4cLkahKdKa9hsNYxeTS6X8PUs4aph+M1T5DXAkFe8wV5LRTktViQ1xJBXksFeS0X5LVMkNcKQV7WJ3J3PDKknlLveODr++uOR4bUMx1dh2ebN5HZptVBPNvEM51RKB+Xb0KzzZsDntxKhMXIyZmuupQqZ64eO9ZgHRZc1e96ehmP4TbZPDzOTUHHNHGzU4u71NUzLFc6JmM/s4bkYb+xluRh210XHNd6veVLfSIXB+JzYXpM71Li68q1Fw4zp5fUL5eql0uYelzbP10VXSJYDzd/oPojUQ83t+jLn32W+DN7XTF/Nhbl4/KHIH/2EFk9w3awO30JtQ0uLrF5a1Ee1Y11KA/LnCbOP1lZlLp6hn019U+cTVR5vXVvd9xds/VXe71tzsWcgVsT4HwN57/ttZw9HYuOqd0mmXNhtjlTkJedS4bFDgmSh+sJu4vBxRqO44N6ehcepxrSZpMKnd04aJKMD7BcV5I8bGOrSB7uK2q32C9aX8TFB1RfSo0P8PX9FR+E3V2j8UGpehl218PV3bU9NT54uYT4wCR6d82Wr0bxwV9JfOBoN2JJvoSzDbzuR/UMxxVUN4qtK9DU1w7HXb27ZtvkNgaoz3A6SnFhHzedwR8miyVIFgcM7eZLy9E6sd1SPefmStyb/xrQMdVxTu+preHrpxMMYbuhHMVr2Sg+A9ffX7uhlkSUa6nxmmSMRecGYWv0juLbyPG2rb+/1ui5uX0DI9f+0O9i/Tw9BI+buWn3R1/D7ulhPOYLBgO83jpU7N5jsXt/9lyxvgm7t87t0Aiz07B762HrQUv74EXvrXMyoDZMy3G8i9XNxZPYzvB5G9dgWdEdUEtJWW4HD42nKopgWIrycV/TtiSY8hw/ep+Yi9kxT3pfeDrDK2wuYe0Mx1m7wy/a+quZdrvwi9z9bm6OZux+IJE11Rncf8X2dSxi2kr9QV+YqD8o9R485jWD8OLuwUvOQbm1wHJ5rRbgxc2NV5A8PM9YSfLwPIPOQdYw+Ky94fXL3WFvtv5qgtWVva0leKh8OHsrNt7h8SBKmbWoXnvO0Lo+MFF7w322jvBa3wevGYQXvt5eW+H17gtu/9L6PvK5dSsPndtA6sP81pKya0lZbg9Rsf8bSuCLMawjZdeFYFhJyi4rUg/XZysRX3sey55+xSGqj1hG8rg9TPR+86rqnb8mxlxXXbze+SH1Lgyp144/mD99imwDwtAagmF6CIbFIRiWeL352z7l1vJw/nymLfY/bnuxuIrut5nJlMexquXH7dek6xJ4nF9F6lnM1FNsHyX+P6hIO6h8JXWD1mf1w2fqqCRlt1Z3456I1oJwGcvDJLdvko0+Dtr6+2s+3tce6LAn6Gn/ck+qU3vA9UR96n2eIK8FwfGe+tRX2NPhWM4unvoqVyfw9f311FfYk+1UL0t9sn0eU08Nc1257eEw0z6XqId7PoLqj0Q9YU99FbsvdQv5agf31FfYfSlb/q+Du3neGvB0/GZp0ae+qJ7hGIPqRjlPfVlZlLNvpdhTqfhat0/cpeujjtv0Le+Oni7rGre556A4X2Nuo9o9pZsK2+cVLljZumVzvnX75q1nLi2cfW5h23bcDMw6xTSTdn+KVGfL0aXB2Z29y+HUXw/VRhUffTwKX0/NZDeoZU67WnJhhb2Wc/MT0TEdTpLMubAho9yXPWJe/f1QuOOhpsCFUzZxw1ChsxsHTX0NC7u6nYq+zCbsxdSlhrS1Xm/5lvtyC3w9DVfwdYkiv7Yeei7KCzk4vaT6X6pezmXqcb2dqr9e0L27wuNiYesLJGzFyx1RwlZb/gUUtv6EhK2OPvpUki/hbIO7pcWFtFQ3uJA2qn/CH33a1e1U1D/hDxDajynZPPwhWvqBTPwRVcsff4CQs+0Wr2deC8qbFhxXElypQDeqSDlZfch2fciJ+/CnW13MRn5ktdg0HOPmYqlyPuSUKbS1N7S2dmTbO9LtrR2FBOFvsdJzeAmX+kRbPs2UdxubZlutveAPOWEbNSmF8uhrIypRHn55CP2Qk5sXpGdbo8gf11/HlJ+F2lBKX0aZu0TlNczrqbfYtjnfRG3RjR+IPnex9VcTrMJ4uuYu07zecp3KyJWLSe21XOxCXyZbarzF+XcJXnbs4caKqaSeFqaelpB6pjKY4/SRSZMKnd04aOorNihl7tKC8mh8iW2MxoRh8wZs0/TWIJZvCzreFT+Er++vJeoW0h6MActrV/RyGlNPDXNdue1pYTDTPpeoB7env+ZiNE4tNndJD+6+Bl8Xde5iyz+G5i5ZEqtiO9hdvoSzDby20ELy8Dyd6kaxlyTSxPknK4ty5i7UP7Uw18Y1Pmhxgyc0PmhB53Y1PqAvYi1nTJ8jyMvqRa1X3HeGyWZaSD34eltuT40PsFyp/XHbxiXjA1w3zrNtpOfCxp/+ig+mkfZgDNNJe0rVy+lMPa7H7emknumC9eD27K74AM+hcHywOUJ8gK8tFh/ci+KDLSQ+aEG44hofUD3D8QHVjXLig5bguNT4AM/l5hXhWcmUPYHk2bIXoP66JziuZa4/3uuZdzzKO5HknYDyppK8FoYn9Q9Y53D5JtIGW74zwG1kOWkoz7PC4+MEq8dWR7GNyuloe9rimcm0kfM/dAvlVaiNE4m+4LU9K/vgKW0v1emkPf6OcZVs5bR6sAM/qpf60SRTnq6fcrESNx5EibtOYHhNQ+fs+uDu1AFsM8V04MaIOmDlujt0AMs1ig5w439UHbAyC1tPS3i9dY3K3KT+1gGLD+vAiahOqgO2/Psi6oCV6+7QASzXKDqAy1MdmMGUx31jZVbn9e732YTXNIZXCzpH7xNY3gM8fjzC4xUufxfqo1E1PfFxY7LNO57hjcflBOGB2zGYaUcNycPXGr4TBvTEb2O4+1BM8CiJ4Rx9CLfrEXAb03BxJ66/kpS/n7GLBLkGy6sFnaM6x+2bmsvIsJbIDV/rVl65Nm6ObBMX19KYN+q6F4158R4BOofBewSwTGji4mErJ9N/MyO8LgTrZoLUaeugtkLtYiqDF8+FqF08juziuRjYBfaDxeziGyXaBXePLapd0DUq7XbRQvKwXVCbiZNdPBfBLvA4TO1iOoMX30Og+5leRHbxMrELN4/0dNsF91E8jH+h1xOzLf/zELvgHoUJ2+vBfZKB86Hc44L22jg9AoXtgNvjRfUb7/Gi+7/wYwt0PZV7PDGqXeBHrqLaxcvELri9xlHtYj7i+wJ5ZNbK7u/ILgYO2Xns9sOL3XZh+7KYXWC7weX/FWIXYZ8eMYnaBfcKG9xuahfY99prHX+oMl3DYLWJ0336OE/UDzVF0X2bh1/dgWVCE2cX+BHhqHZhdTNB6rR1lGIXCxDfW4hdWHkMQa8THEvsArfdhV3gR+w5u1jh9cTc9UqPACdnF9ynVrjX1lIMuDxuN7UL7pUGbuVV31DDYLXJ5uFHyOnrhKK8+gTbls3Dr2Sgj7biVzTQz+LgxNmFlVMpdjGW2AX3Oo2odrEM8bWv5aR2MQ7ZRX3/2EXets32ZVS7sOUnlGgXYeMF91qiqHZhr3VsF7F6bbnN41754tIu6h3ZxWfJpzS4TwnYOvt6VSBdz3X0yrB2quvF7Gc5ysfljw+xn6ivHwyzN+7VLGGf/Nqd/mYpg4f6m5mMvLj17yWoPSalOp20p8Ctf+N+q0T19tVHJpXqE63MorxqiHt9LmeTlif+ZA6d2yxBY1V7DOY2+P5+sbnNihBb4+Y22J+UOrexeF4vcxsaw2HfQec9cZrbtEeY2+C1QjpWzWPw4g8X03WlU5FdXEjsor9en1vMLvDnrnD5LSF2wb06lnseO2xcxu2mdoF1314bt1ef0zgN6zfVfU6/6VyKszXst7FMaOLsAr9qPapdXEjsgvN/Ue0Cvz7ulUE7j6ldXIbs4kYldnFliXaB76fs6XYRxe/H0S5udGQXDxaxi3ciu7hLiV28Z+940ZVKtQt6f0SLXdzlyC4uInZh9+x8HNnFl4hd4P19LuwC30vn9qDM8XpituU/GWIX9hosL7y3idoFd28et5vuQcF7ney1buUlu+96OsnDcwM698D3SOn+dmwLWCY0cXZh5VSKXXyJ2MVsUgfuK5PC9qDMRnx/P3Dnse3fOlRuktczbzLKG+31xHM0gweXH0zKT0EYuPKWXyUp/wTSfbvnzepfGl0vaK9tFrOPMCWZdqUJZlv+qRB7TTNyOwqdo/bqM+Vxuy2eWiI3fG0V+e9KXhlGXkczeCpJ+e9GXHurQ+0xKdXppD3t3Nob7rdKVG9ffWQS7dMMUx73jZVZHSmP+9fmTUJ5aZKHbXYywVDHYIi619Nea2x5eODwOJ9B/QnWBepPpjB4cHnqT9IIA1fe8qsk5X8Z4k8c2UdrmH3gdhWzj9+E+BNO92rRuVJ1j/oT7GvstVVeb7104U+yjLymMHgqSfmXI/qTyag9JqU6nbSH9Se436g/Cesjk2ifZpnyYT4ji/Koz8D+xCd52GaPJhgmMxii+hN77Q5bJv4Elzuc1DmJqROPpTM6d/5WMZhd3HvCPifp9ZZnsRinIlBOzr65OGs/dI7qQl9+NCzGs9c6lldbmLyOiiCvKkZenH0PRu0xKdXppD2sfWPdpPbN9SkuX2qfWpnVeb195GSSh21oEqlnMFMPtidqw7iv7LXGhr8fNKAa5dvfct6h1t7W0JYz71Hzcw3ZXDo/jPA3ycpusIP6c/Wtje2tjb7fnPMLOb++v+svtOWaG9ua2+vT+XSz35zt7/obW5ug9uZca64h3Z5ubOjv+jNNTQ3NmbZ0rjHf3pHP9Xv72/IN7enmrJ9vbW2E5jf1e/vz+YKf8xubmwq5XL65//WvqRkUr6PQ6vt+Jp8u9Hf99fm2pnRjprU5396Qz9a391W/8csvBf+tz6pAZe11drxLovOC40Pkd93Yc9UEqzCernfdJAkeKp8KIrsUg7WO5Jk0u7O7HM1LMucq+plXrde7v+mYy8kmGVIP7SuTapjrqM5RmbYE/9PlpcifNLD1V3tObcAP6z9OrlZ2lQzWOpJnEtWTSqaeSqYeLbzs9SZRezRpQWfPPNzHVKZRddW+x4X60lqveN/YuoNHgHucr2TwVpLyK8mazECCtSX4ny4z0bED11XFtE+w7q498AO83qmGaTft90Eoj/ZtFcGM8/B4TL/7gVOS/MeyMHV3RriHwelIguQNYNph82i/m1Tn9dbtSpKHdXsAycO+bSDJw7Zk39+dIDw9r9tmcd/ZeVGtV9z2BqPzAzt78tvxi85VBsdWvoNweZJXhfJSnd31mlQd/E+hejAvi6OSlN8WMLfriAPQNfb6Oqb+AaT+HriZc7ivKK8kc86W3/EOqABjsTgP9w8dcx35lMhjrq2/2uttBy7G3IEED5UP9SGDGKx1JM+kxZ3d5WhekjlXUYQXtZlyeVUI8rJ+gbPtAaSeBFNPIqQeer1JVcx1LcFvurSUoycsbzpG7CJ/mlrpOIMTt+7L2QuWH04Yd6nvXsT6MJjk4XFwCMnDfqKG5GEdCYbDUP+/qzpCr8cY8HWJIr+2Hq+PejjMtQwGGudxY2NFSD0ppp6wufmutofDzMXN5daD2zOQ1DNQsB6si4NIPTiuxu9evIPcS7DX4fV2fO2czu58XD41tJvnnSQ+x3Yg6EuaaTyLExfPUtvAfobq2RCUR3WjBuVhmdPE+Scri1LfvYjHgWrEn9plkrl273qW+/UsGufs6hoU7etyeVlZ99e44zh+bqJjK06cPyh0duOgibNPi7vU+AHLtYrkYb2vJnm4r2jcgfXA+iNu7psgx1wsj8+Fjev9NT6F6WWSlCtVL5NMPa7joSjrubtaDy7TX3HKAFJPsfjhRRI/2OuKxQ/03c22/B9qunn+jMQPjtbYSvIlnG1EjS2obnCxRYLB0NcaWynxA/bV1D9xY8Jgr3cf/Qn1USKI9xzHeF374i1mTq9w/ZWk/F9D9s1wc34uFqAYcHncbouHW7u018YtJqY6zc29Ob2lOo1jYuqjhqI8LBOa+oqXo+6LT5D3cA8gdVCfRPesVDJ4sa+jc58BaO6zH7ELR+soOds225fF7ALbDS5fHeDk7ILTc24tkGLA5XG7qV1g3bfXxnXdidN9OkeIqvvU1mpRHpYJTX2tc0W1i/2IXXD+L6pdDEJ870A+9iXCj4vFrJyoz8XlPeZcwis+XtE6kgy/mZ0981IRsHGxl8ec47Al+8CWYrBRvhUh7ShWT5T1M07HOexO9ohl2utbs/XN6fZCfWNrQ2O/79HrgFo7GtP1mXyukMm39lU/d48L7yE1yd4nw/fRcHnLr5KUz6Kxo57YcSVTnyk3I6RcosjvDh7MuVRnz3Pc/TV839GWt3VXd/bGaPMGo7xKUs+Q4D+WF+ZlcVSS8tOCtts+wfcK7fV1TP2DSP09cDPn6H3HwUz5wUx50z/HBBi7xmZUt/Sa1o46CX98jmKzulNsvwa9z4jz8Pyd+r2udWB0Hq8d0L0ctvz8/omX2L0cVaQNA1EbuLiHzl1t+U3IhhcN7Skz7v4dJ096P4XOD3Aexm3lbeU32I38uuZhNg7C8SbGOtjrKSNbfhUTb3L78Qeg9piU6nTSnhy3Hx/Hhthmcbs8r7vduDwdV4cw5XHfWJnVkfI0zsL/MS8cu80iWPGcJWyeSuf3baiP6LcjsN1UE+y47XQvQJKpl1tvqkKYLyM+wdHeh0ZujdMm7h4ujZewHdI4q5pgxnlYD0pd/7GyKHWPlYQfwnObHfg6e+PaHXaL56vUbsPmpp7X2277snO79lnn9e5Lqt/cWFOKzZg0i9SH9QXPwS4rMq73tX57ZZG1klLXb9+DxsCryRgoub+vL72k/Wvrs76E2mVL8D9dXoq8r6tr/cXzXMY7fpj+c2s5juOHXNi4yNnjPt7OtRPaZxif5YXn0XZ/QtgaLNX1vmRTx1xP943iPg7bb0r9QJT9pljfB3vhsXqC8Cq2LkjHg6hrpDT2vR3Z/aPE7sPu93F78bj4lto9tz/Z6i5dn24J/qfLS1262zXf9niZ4tgYl78zZK2Vswdu3yHFgMtzsSP3bHTXfmDyX1heXXOFoX3Iq4bIy5a/N0ReXPsHhshrKFO+JkReWJb4Wlp3MV/UX7rYl2ypLtryD0Schw1C7TEp1emkPfVcPIdjsEpUbzF7weWj9D9nL3WkPO7vsH0SnI8fTPKwb6b+H/t469uwL+3rnpSN33LBuSpGDpJxBfbN0vyb0rl2et9S2jc5fqYu63jPQtrqHZ7zc89PWZ2z8To+tpi4PTH0ng++vzKb5OF5iuVt7NmutZnjkV73NSbNQRgSJG8uyqsgefM6e2I3yWVfgi42O+7L7HCveP9ZO5je6aTujOU/ww3/Lj8x0w3/rJ3n2vdLJIvogkd0BZ+TwsLNsROkXkdrWJH32dr6qz2nOu1HnU9Y+zZjsR0vt23fek7rpsLSQmseQ8fsuKbhpuMydGtcgvynt45peY5PWEowfLmmz+jc+RtlS26yD17TCS/uVjp3KxtjpG7UpJbgt1g/d0RMtj7bfwMZLLZeuqR0RPBrzNwnckn1IZeZRC5cfYM9t+FtY1M6bfvWhtaVXu9lXVx/JSmfDv5L3wKHO+B+R7a1o7W+NZ/Ptbf2+2s6WtOZQs5va6v3C63NzR191f/u4Fh3eNvY2F/hbdIN/4zj8LkrvKWhqkfq3dXw1pbhwlsbmhp/s7/XfXyw132NSThMpSEsDlNpCDuf4MN5C1Aevc2yEOXRpfSoj+263HYKoXKH29v3mSZuiQJvpzMphfIGkbxKlIe3zm0l8nHx2ArIp9Xttt9MfjiDny7hvF6mEp4c77TlPcsN9qzlP9sN/5ydBl0Y8At7LMTtdDZTSJD6PI+P17teJeE5HUu6piLc9gnu8TkzFbGvzdxU2L743LYtm9tntG5vXX5OobBq8/YzC9u20XmH5T0Zncf5OE0m9XHl8LhByyWZ6yr6aNuMzp2/UeYafckpbK5Bx6UBffCaRXiF3Zoa2Aev2YQXvn4guW5QkXqSXu/bCbg85sHxtzxcjiPp4DYzHsM4meD6udtt9PGf/r9dnmmO6ivicLucuz3t9nZ5pilB+GM8gxn5cI8p0MfTuNuXuPxg1EZcHh/b6/G56cEv3cpmkh2zE0xekjmHt6pOJW3DfZMo8mv50nP0Vj6WDX00y1UM63iLRZouy+O6jDznovM4D+sDd6uqkpRfhXguCI65dZZqksctzSa83v48bIyO8kgst22Ik00lyePGIO5RbPoYT1/bNDh7DbMHbkuI1Z2hpG0twf90WSnT9Xpyu62+mI/At51x+Q3B745tiaSN3C1Yrm8pBlwet5s+Co/9VG3/yKspTF7JCPLKM/Li5rj983ryTLPBcSXCQXWzEtVbrE85Px61T63M6kh53L+c7x5C6uHGSxw3z+j0erQxiq80aWBnT747ftG5SsTXpP5+Hd8Fwf84v47vnOBYw7r7ZcH/19u6e6mv53b56Ns1tizQdcFxX4++3RJSLlHkdwcP5lyqs+e5uD/6dnPwP86Pvr3V8gt+cdul52s76iT88TmKzeqO0Wv7mRrl26X23k/qI9n4eUZnT/6ex88dsH+w13D3imYGeSZusnGMOa5F/EzC68pdfobwE9aJBsd95g8vgt8kux493OtOPWyTyALzqWHyMN+4xwx27Xh3xwx2z8Be3xaasi7tMB3Ix6Edsr6Ns8kw30b9Vx26xqSZiHeC5M1i6nXZZtCJesfjRWa4V3yMoPdRvV2v16cnrN8cQ+To6tMf3JZFD/WvyeMeGU0w5amPxLhNmw5FfGk5WifWX7oGx62LcWNGRQhPTePJIcH/3T2eYL3k1rgoLluGk7vHnEt4xfuQ1sGt6Vh75O6DFcPG2bfHnOOwcfdhufoxNsq3IqQdxeqRfq2P1a+9cUJo2jsH8vbOgUiKNAc6wOtOWM6VXnF/V0nK2sdndnxGuwi/KHOqZJHr8DoIN863eDLy4nAkGBza54AHB/9395jdFBwr9+1Nyn17Li6+PUnKcdeE+X/H/tr1vC7r+DGsrkfew/bQ4fq5RygTRX49r/f9C1xXf32WkWsbxk/3aIR9+o/jFfUTh/S1D7ujT7GscZ/uKNPZnVdB8lIor5LkVXb2bqOJIw5C5YrFHKbckej4KCIjl/7ZlV8wabhXPLax5+J+b35i8D/O9+btGs1grzt+zSB+xewAzwfsMbffCz/W7NBmMwmvt1+i/gXXb/aPjAiOzeOnhTlnzjy/0H7u9s1bz5ze2n5qATthysRjGm/zEuh8sUGZXpNE5XHSEPg2Bv/jsFjlIXk5et9X10MvrjZzcu8kxBtgB5M8KwPuYeVEkf8V5DesLD2Pz9UweZannbRivPid7/h3BOLrYpKyrxv+bF+NQMf7knZiebcIYbD8rM1yC/sVJA8HDxhfQh6fT7EkmbpssjqzLzpn5bkPwerqPSuWv6vvrlr+jh4UyXI6ic9RHaDjHMZE7VQYa2tXIIcwJEmdFCMuw/m8CvKfjrnJCGU53bR5XQFbyHX0IR16jk4cPKZ8V/AX/FYW4YXf94fLDyRlXfXhcAaTxf7/tC+091JUBgA=",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_for_L1_to_L2_message_consumption",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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68z2fbWqXmc6c1e9znTmPnWd+TxDnH6GNP0MefoZyvQzDFB/VW5aIQbpPadx2au5Jd6lxL0fvHy3pVxGvNL5rqm7807dn3fq4bxTl/NOPZ536um8U8/nnXo579TPezd1572buvPeTd1576buvHfTES/Yvmvq572buvPeTd1576buvHdTp+du+jEdr+cO+TkdPXe9z+nouZN9TkfP3elzOnruOJ/T0XMX+ZyOnjvD53T0rPaf09Gzgn9OR9eqHHStykHXqhx0rcpB16ocdK3KQdeqHHStykHXqhx0rcpB16osulZl0bUqi65VWXStyqJrVRZdq7LoWpVF16osulZl0bUqR12rctS1Kkddq3LUtSpHXaty1LUqR12rctS1Kkddq3LUtSonXaty0rUqJ12rctK1Kiddq3LStSonXaty0rUqJ12rctK1Kmddq3LWtSpnXaty1rUqZ12rcta1Kmddq3LWtSpnXaty1rUqF12rctG1Khddq3LRtSoXXaty0bUqF12rctG1Khddq3LRtSpXXaty1bUqV12rctW1Klddq3LVtSpXXaty1bUqV12rsqJ3aS/TqYrej/2cjqpVuSp6j/VzOqpW5bqoWpWrondIP6ejalWuit71/JyOqlW5Knon82M6it6z/JyOrlVZ0fuQn9PRtSorem/xczq6VmVF7xd+TkfXqqzoPcDP6ehalXW921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdtXdb3bV3W921d1vdvnFl0v913mo2pdvsxH1cJ8mY+qlfkyH1VL82U+qtbmj08iK5vP0atzXW6/7GpozOfw5TmndT51eZzP88Flka9jy8PUffPYS3H0dexljf/l2GucFSPO419LfFOcDiRODxJnAIlTQOKMIHEmkDgzSJwgesiB6CEPooc8iB7yIHrIg+ih41+6flOcIHrIm9FD6XbsRxOyEagZQdQL1Iwi6gVqRhJ1Ag1mNFEvUDOiqBeoHlV0nY8e9XKdjyibjx41cJ2Pnrv2dT56bq7X+ei5B17no+dW9Tkf0XNHuc5Hz8J/nY+y9VmUrc9H2wl4l+vXwZJr3L5RSyi3Y5Osh15+ofXD9+3W4FxHAaRl/eW05HD/aRe/YImQsES5qZ0U89KAJRGWFiyZsLRgKYSlBUslLA1YjrbfOAssjrC0YPGEpQVLICwtWISwtGChym3CQpXbhIUqtwkLVW4TFqrcFiyJKrcJC1VuExaq3CYsVLlNWISwtGChym3CQpXbhIUqtwkLVW4TFqrcFiyZKrcJC1VuExaq3CYsVLlNWISwtGChym3CQpXbhIUqtwkLVW4TFqrcFiyFKrcJC1VuExaq3CYsVLlNWISwtGChym3CQpXbhIUqtwkLVW4TFqrcFiyVKrcJC1VuExaq3CYsVLlNWISwtGChym3CQpXbhIUqtwkLVW4TFqrcBixuocptwkKV24SFKrcJC1VuExYhLC1YqHKbsFDlNmGhym3CQpXbhIUqtwWLo8ptwkKV24SFKrcJC1VuExYhLC1YqHKbsFDlNmGhym3CQpXbhIUqtwWLp8ptwkKV24SFKrcJC1VuExYhLC1YqHKbsFDlNmGhym3CQpXbhIUqtwVLoMptwkKV24SFKrcJC1VuExYhLC1YqHKbsFDlNmGhym3CQpXbhIUqtwWLUOU2YaHKbcJClduEhSq3CYsQlhYsVLlNWKhym7BQ5TZhocptwkKV24KF3z5rw0KV24SFKrcJC1VuExYhLC1YqHKbsFDlNmGhym3CQpXbhIUqtwULv33WhoUqtwkLVW4TFqrcJixCWFqwUOU2YaHKbcJClduEhSq3CQtVbgsWfvusDQtVbhMWqtwmLFS5TViEsLRgocptwkKV24SFKrcJC1VuExaq3BYs/PZZGxaq3CYsVLlNWKhym7AIYWnBQpXbhIUqtwkLVW4TFqrcJixUuS1Y+O2zNixUuU1YqHKbsFDlNmERwtKChSq3CQtVbhMWqtwmLFS5TViochuweH77rA0LVW4TFqrcJixUuU1YhLC0YKHKbcJClduEhSq3CQtVbhMWqtwWLPz2WRsWqtwmLFS5TViocpuwCGFpwUKV24SFKrcJC1VuExaq3CYsVLktWPjtszYsVLlNWKhym7BQ5TZhEcLSgoUqtwkLVW4TFqrcJixUuU1YqHJbsPDbZ21YqHKbsFDlNmGhym3CIoSlBQtVbhMWqtwmLFS5TViocpuwUOW2YOG3z9qwUOU2YaHKbcJClduERQhLCxaq3CYsVLlNWKhym7BQ5TZhocptwcJvn7VhwVS5OYcbLMWXX2BpHe3Wg+9YuLJ8QYipiIdCiKmeh0IohPCnEGKq8qEQYir4oRBCqv1Ya7xDWDsQXiaabvMo4Q64L62jXXL562iXwn3awacvyCErifdCDlmlvBVyzO/i5ZhvIOYkSwfyEPztl+U+Y+dbXKZ4++FLZfV4cHvOdf3lZSm/HH1lB7IQOw07kDXeadiBLB9Pw46QHcXsQBa9p2EHsp4+DTuQpfpp2IGs6k/DDmQD4CzsYH5d9DTssFegmR32CjSzw16BZnaE7Chmh70CzeywV6CZHfYKNLPDXoFmdtgrUMwO5jeaT8MOewWa2WGvQDM77BVoZkfIjmJ22CvQzA57BZrZYa9AMzvsFWhmh70Cxexgfun+NOywV6CZHfYKNLPDXoFmdoTsKGaHvQLN7LBXoJkd9go0s8NegWZ22CvQy87lP5IdxeywV6CZHfYKNLPDXoFmdoTsKGaHvQLN7LBXoJkd9go0s8NegWZ22CtQzI5jr0AzO+wVaGaHvQLN7LBXoJkdITuK2WGvQDM77BVoZoe9As3ssFegmR32ChSz49kr0MwOewWa2WGvQDM77BVoZkfIjmJ22CvQzA57BZrZYa9AMzvsFWhmh70CxewE9go0s8NegWZ22CvQzA57BZrZEbKjmB32CjSzw16BZnbYK9DMDnsFmtlhr0AxO8JegWZ22CvQzA57BZrZYa9AMztCdhSzw16BZnbYK9DMDnsFmtlhr0AzO+wVKGYnslegmR32CjSzw16BZnbYK9DMjpAdxeywV6CZHfYKNLPDXoFmdtgr0MwOewWK2UnsFWhmh70CzeywV6CZHfYKNLMjZEcxO+wVaGaHvQLN7LBXoJkd9go0s8NegWJ2MnsFmtlhr0AzO+wVaGaHvQLN7AjZUcwOewWa2WGvQDM77BVoZoe9As3ssFegmJ3CXoFmdtgr0MwOewWa2WGvQDM7QnYUs8NegWZ22CvQzA57BZrZYa9AMzvsFShmp7JXoJkd9go0s8NegWZ22CvQzI6QHcXssFegmR32CjSzw16BZnbYK9DMDnsFetmRhb0CzeywV6CZHfYKNLPDXoFmdoTsKGaHvQLN7LBXoJkd9go0s8NegWZ22CtQzI5jr0AzO+wVaGaHvQLN7LBXoJkdITuK2WGvQDM77BVoZoe9As3sQPYKYq23KecSQ4+d4sPtp0u8/3Sord924m+/7STfsXNLaP22y/dpPyDtY/PoJbj16JjvR9fcOLq4dJtJ8Uu9H92mMS9hZeYj9W5RSvhKFcjGBVNlR6p4yC4KU2VPqkC2dJgqe1IFsr/EVNmTKpDNLqbKnlQRpgpT5fdSBbINyFTZkyqQPUmmyp5UgWyQMlX2pAq7tUyV30wVdmuZKr+XKoHdWqbKb6YKu7VMld9MFXZrmSq/mSrs1r43VWS54REk+06qXG4Ct2dKJHzge/vt9MWmkE1DbLLnaYlNtiUtscnOoSU22dyzxCb7b4bYFLbILLHJLpYlNtlossQme0GW2BSyaYhNgF7QNVCANsk1UIAOwjVQgOL6GihA3fkZaAQoya6BAlQr10ABhPw1UACNew1UUAJFUUYRRRlFFGUUUZRRRFFGCUUZJRRllFCUUUJRRklQAkVRRglFGSUUZZRQlFFCUUYZRRllFGWUUZRRRlFGWVACRVFGGUUZZRRllFGUUUZRRgVFGRUUZVRQlFFBUUZFUAJFUUYFRRkVFGVUUJRRQVFGFUUZVRRlVFGUUUVRRlVQAkVRRhVFGVUUZVRRlFEFUUZxAVFGcQFRRnEBUUZxAVFGcRGUQEGUUVxAlFFcQJRRXECUUUT49P1noAhfkb8GiqKMEL5tfg0URRkhfHH7GiiKMkL4DvQ1UBRlhPB14mugKMoI4cuw10BRlBHCVzmvgaIoI4QvIl4DRVFGCF+juwaKoowQvgR2DRRFGSF8hekaKIoyQvgCzjVQFGWE8GmTa6AoygjhgxjXQFGUEcJnFK6BoigjBPP9a6AoygjBsv0aKIoyQjD6vgaKooxQPLAjigd2RPHAjige2BHFAzuieGBHFA/siOKBHVE8sCOKB3ZE8cCOKB7YEcUDO6J4YEcUD+yI4oEdUTywI4oHdkTxwI4oHthRt6WlWwP1+ZdAr3PXowGu89Fzq/6cjyKHwOt89Nz4rvPRc3+6zkfPbeQ6Hz2r/XU+etaq63z0VJXX+egp/q7zUbY+KzJA+5yPIp+y63yUrc+KXL+u81G2Pivy0LrOR9n6rMiR6jofZeuzIn+n63x0rc9JkVvSdT661uekyHvoOh9d63NadK3PSZHhznU+utbnpMi+5jofXetzUmQG8zkfRZ4t1/koW58VOaBc56NsfVbkJ3Kdj7L1WZE7x3U+ytZnRV4X1/koW58VOUdc56NsfVbkw3Cdj7L1WZGrwXU+ytZnRR4B1/koW58VvXF/nY+y9VnR++vX+ShbnxW9DX6dj7L1WdG71df5KFufFb2pfJ2PsvVZ0Xu/1/koW58VvUV7nY+y9VnRO6nX+ShbnxW94Xmdj7L1WdH7ktf5KFufj377UEr2t/nUJTzPpx49n+U+H+ce5/N8cFnk69gS6nqobx5bS/o6ttZfj/2M8+h3BN8WpwOJ04PEGUDiFJA4I0icCSTODBJnAYkTRA8lED2UQPRQAtFDyYweSrdj3bL4RqCCEqgZRdQL1Iwk6gVqRhP1AjUjinqBTlVFn6fIy/xTuPmn8PNPEeafQuafIs4/RZp/ijz/FGX+KeZf3WX+1V3mX91l/tVd5l/dZf7VXeZf3WX+1V3mX91l/tVd5l/ddf7VXedf3XX+1V3nX911/tVd51/ddf7VXedf3XX+1V2nX915Weafws0/hZ9/ijD/FDL/FHH+KdL8U+T5pyjzTzH/6nbzr243/+p2869uN//qdvOvbjf/6nbzr243/+p2869uN//q9vOvbj//6vbzr24//+r2869uP//q9vOvbj//6vbzr24//+oO86/uMP/qDvOv7jD/6g7zr+4w/+oO86/uMP/qDvOv7jD/6pb5V7fMv7pl/tUt869umX91y/yrW+Zf3TL/6pb5V7fMv7rj/Ks7zr+64/yrO86/uuP8qzvOv7rj/Ks7zr+64/yrO86/utP8qzvNv7rT/Ks7zb+60/yrO82/utP8qzvNv7rT/Kt7/rNqef6zann+s2p5/rNqef6zann+s2p5/rNqef6zannAs2oxxNvLzTGmun3wuIf+84Bn4N429XraqQ94Zu9tU3fnnbo/79TDeacu5516PO/U03mnft67aTnv3bSc925az3s3ree9m9bz3k2r5rvp9vtiecBDyO+bu+b7aW/umm+ovblrvqP25q75ltqb+9R76scpyrLMP4Wbfwo//xRh/ilk/ini/FOk+afI809R5p9i/tXt5l/dbv7VPeDZ6xjL7dvKKQW3ffD2d5jLgCecN6ZzPUWZf4o6/RQDnnDunuLn2ZeX4G4HL7Fzd/fZ5a+DffZ3D9GYvubjlc0nKJuPKJtPVDafpGw+Wdl8irL51KPnI7LOJ6Wn+Qx47HzsfJyy+Ry8PgeXbgeHDwHxNJ+gbD6ibD5R2XzS0fOJfnM+B68/IaRwm0/I/mk+siibj1M2H69sPkevPyEu63zSL/Np1GHLejHK0kh+EdWTL6sh3FKf70QSz4J8a/JHL4OhrsuyPHwqYV/aZNWT76RNOQvyrckffbcSX9bJx+VpPnFRNh+nbD5e2XzCO+cjz/MRZfOJyuaTlM3n6JXfr18cCpLq9uL54cT4dfDHq5nrwS7cZn/06pnDqh2zxJ/ddNOievLbN93kzoJ8a/JHL+Kp3if/awumkfTLerBzYXlO+nT0kp/z7dGfUH69BbWgvzUHxf96wTYiDfW2Njl5MIi+rBFfkQpMpBEm0gQTaYaJtMBEWlEizcspI73O3Z147v7Ec1etTMJtFpJLY+5y4rm/uKfW2xlycuVxOtdRedeosmtU3TPq1Tt9nVFu1yi/a1TYNUp2jYq7Ru3KjbIrN8qu3Ci7cqPuyo0RrykMfG5uxJsHI6cTdU0n6ZpO1jWdoms69eDpyHpLjL9OpzX1ep+7ux99vX3WZTnv1N15p+7PO/Vw3qnLeacezzv1dN6p5/NOvZx36ue9m7rz3k3dee+m7rx3U3feu+nhr2ENnPp576buvHdTd967qTvv3dSd927qz3s39ee9m/rz3k390XfTsM4mSWfqvee56oB3Id84+XjmyaczTz6fefLlzJOveicf67pQpriU7R/+eG/+62C/LPfnC51c+9s1LDCRulNGep27P/Hc1dy5r9OZavL8fPBFy9yeDJdc73nZtIna3oyqc7/aNHnu5cRzr+ed+9wPWE2euzvx3P2J5x40z31cUTn3g2KK4owgcaq+tw+MU7UOGBinas0wME7V+mJcnFG1FvlGzdOxc61RtXAZGahqlTMyUNWSaGSgghKoalE0MlDVqmhkoKpl0chAVeuikYGqFkYDA00oyiihKKOEoowSijKa+wlbTYGiKKOEoowSijJKKMoooSijjKKMMooyyijKKKMoo7mf/9YUKIoyyijKKKMoo4yijDKKMiooyqigKKOCooyKFWXko9x+2Mdatn/4YyvmBsslqR9g+XpUtljRUd+DpazOsH4Jv8LyfHRx6RZg8UvtHC3lbu12OXw9Okj4gtyKojsR5Fa05Ykgt6JyTwS5Fb19IsitKP/zQF6t1CAngtxKNXQiyK3UZSeCHLNCfCvkQsiPhpzV548gv4LIenIAiKwQB4DImq8Pond3EKPvHJ3vcOSLJugcHdb+qjystl6a0NX18+He+ceDr1SylrRBpV8W1qhmqGTta4ZK1tRmqGStboZKIZVWqGRvwQyV7HCYoZJ9FjNUsttjhkp2e6xQ6djtMUMluz1mqGS3xwyV7PaYoVJIpRUq2e0xQyW7PWaoZLfHDJXs9pihkt0eK1R6dnvMUMlujxkq2e0xQyW7PWaoFFJphUp2e8xQybryNFT6cKdS4hOVgQr2NFRmt0aYQ3imkgrWDJVUsGaoFFJphUoqWDNUcr/SDJXcrzRDJetKM1Ryv9IKlcL9SjNUmrlX1uU25eDcsv3DKcqtB5Zivh/sXPyCxcx9ZywsZtbwobCY+SL4YFjMdJLHwmKmKzsWFjMdzrGwCGFpwWKm8zYWFjNdrLGwUOU2YaHKbcJClduCxczX3QfDQpXbhIUqtwkLVW4TFiEsLViocpuwUOU2YaHKbcJClduEhSq3BUumym3CQpXbhIUqtwkLpMqNtd6mnKprwSKEpQULpMrtwwKpcvuwQKrcPiyQKrcPC6TK7cJSIFVuHxZIlduHBVLl9mGBVLk55tvThznJr7A8Hx2Cv/3yw7umH28QP+Od1scaL0XF48HtOdf1l5el/HL0lR3IlV8JO2GpNzCCd72j820WOa9HSr7SaOfb3Ng0Qt5Z7dEIqQTs0UjlYoJGIY0WaITsf9qjEbJfa49GyP6yPRoh++H2aGQXxwCNzs7X67FpZBfHBI3s4pigkV0cEzQKabRAI7s4JmhkF8cEjezimKCRXRwLNNr5cPK3aAx+jS9L6NDoLoR8He1yqvejQ5PJ5eZFFx8T5HLsFXDM0uCNgAsBPxZwTLn9RsAxhfEbAceUsG8EHFNsvhFwzM299wFu50OzZwEcc8PsjYCz0hwNeLq96//okN4+Vny8sSO+yC8dgys91DSD6SnrwSWHzrE++NvBXsStR79wsHfp7mC/1M7RUpZ8Q688uNKHS7xX6qmuYKmnzkOlPlBxwlJP7QtLPVU4LPXceYKlXkg9KvXcjYOlnvuCsNSzmwdLPbt5Jqi/ksn+nB0y7Xycl2Q6YQ/tPGQq+eKzq7cNW++dfzz4mlLszTGlBqcUe35MqcEpJUwpptTYlGKPkik1OKXY+2RKDU4p9lSZUoNTir1aptTglGLHmCk1NqUi+9ZMqcEpxe45U2pwSrF7zpQanFLsnjOlBqeUMKWYUmNTit1zptTglGL3nCk1OKXYPWdKDU4pds+ZUoNTit1zptTYlErsnjOlBqcUu+dMqcEpxe45U2pwSrF7zpQanFLClGJKjU0pds+ZUoNTit1zptTglGL3nCk1OKXYPWdKjU2pzL4UU+qbKeXDPaUePpK3ppQwpZhS30up7G4U+hzCc0qx4mNKDU4pVnxMqcEpxYqPKTU4pVjxMaUGpxSfl2JKjU2pwuelmFKDU4p9KabU4JTi81JMqcEpxeelmFKDU0qYUmNTqnr3dXCNsXNsXPL6gV63PMzj9s3dwk60anrY1VVNDzukqulht3G0nCm3T7i7ZUk9PXP/gMVljz339MzYbxAVtgVhua/s3+Fyz0YbLvfsiOFyz9YVLvdC7mG5ZwMLl3t2x3C5Z+sNl3v29XC5Z1/PBvcfbPqFnTpLbLL3ZolNdtNOxOYpXs/2C7t0zKnROSXMKebU4JxiV5E5NTqn2K1kTo3OKXZBmVOjc4rdVebU6Jxi15Y5NTinHHvHzKnROcUONnNqdE6xj86cGp1T7KMzp0bnlDCnmFODc4p9dObU6JxiH505NTqn2EdnTo3OKfbRmVOjc4p9dObU4Jzy7KMzp0bnFPvozKnROcU+OnNqdE6xj86cGp1TwpxiTg3OKfbRmVOjc4p9dObU6JxiH505NTqn2EdnTo3OKfbRmVODcyqwP8Wc+m5ObX973AfWfcyp7+bU9hd5fGDdx5wanVOs+5hTo3OKdR9zanROse5jTg3OKeHzU8yp0TnF56eYU6Nziv0p5tTonOLzU8yp0TklzCnm1OCcYn+qn1PJy5pTuZsmdVl3LmrsfdpeluWWgrLIQ75+far3kjokaCxBYVlun1IOS+nSGfx61Yu43lU/9JsePlJFAJMvJB+XfO5vA5PPjWhg8qnIgcnn1i4w+dyDxSU/cbMUmHzuagKTzw4fMPns8Bkh/0qnkE5LdLILZ4pO9tXOROc53m5M7NcxqYYnFfuATKrhScX+IpNqdFJl9i2ZVMOTiv1QJtXwpGKflUk1PKnYv2VSDU8qYVIxqUYnFXvZTKrhScWOOpNqeFKxo86kGp5U7KgzqYYnFTvqTKrRSVXYUWdSDU8qdtSZVMOTih11JtXwpGJHnUk1PKmEScWkGp1U7KgzqYYnFTvqTKrhScWOOpNqeFKxo86kGp5U7KgzqUYnVWVHnUk1PKnYUWdSDU8qdtSZVMOTih11JtXwpGKfikn17aTqfNW3svpjUn07qbY/cXFBgEnFpBqdVKz+mFTDk4rVH5NqeFKx+mNSDU8qYVIxqUYnFZ+nYlINTyr2qZhUw5OKz1MxqYYnFZ+nYlINTyp21EcnlVvKOpGYO0dfQFi5LA/g3b7ve/k1EqSbIHZ6lRPErqlygtiBHE5QXgnyvkeQv38X47IBn3vCZugHjoITko9LPjt6wOSz8wZMPjtkwOSzkwVMPjtOuOR7drOAyWenDJh8duGAyWeHD5h8Ifk2yL/SyZ6dKTrZhTNFJ/tqZ6LzFO9yB89+HZNqeFKxD8ikGp1Ugf1FJtXwpGLfkkk1PKnYD2VSDU8q9lmZVMOTSphUTKrRScUuMpNqeFKxl82kGp5U7KgzqYYnFTvqTKrhScWOOpNqdFIJO+pMquFJxY46k2p4UrGjzqQanlTsqDOphieVMKmYVKOTih11JtXwpGJHnUk1PKnYUWdSDU8qdtSZVMOTih11JtXopIrsqDOphicVO+pMquFJxY46k2p4UrGjzqQanlTCpGJSjU4q9qmYVN9Oqu1PmIfE6o9J9e2k6nzFJ7H6Y1INTypWf0yq4UnF6o9JNTyphEnFpBqdVHyeikk1PKn4PBWTanhSsU/FpBqeVHyeikk1PKn4PBWTanRSZcg+Vax1hbvEXlKF4sPtp0u8/3Sord92Idw+6eBCcfffXkIzxFu+Srmj4SR90QPZ8TkPPUJ6NNMD2YU4Dz2Q9fx56IGsjM9DD2SNqYeeuIrwmFr0QFZrp6GnQD5JpIiefJt1zLVBD+QzOeehh12D99KzPnubltCgh10D1fQI6VFCj3MNetg1UE0PuwZvpSdld6OnLA162DVQTQ+7Bu+lp9wmkqo06GHXQDM9lV2Dt9KTlxsc2ZUGPewaqKaHXQMt9PjUoIddA9X0COnRTA+7Bu+lZ51IWVrKjV0D1fSwa/BWesq6uJWmcmPXQDU97Bq8l55w++ki/okeWdg1UE0PuwZa6IlLgx52DVTTw67BW+mp7nZwbZSlsgjp0UwPuwbvpSfcdkuruAY97Bqopoddg/fSsz5jXVNrcWPXQDU97BpooSc/t0TFsWugmh52Dd5Kj1vibdpuSY3C1LFvoJwgdg5GEyT+9ttOHt1PmgQFl+/TfkDax+bRS749lh2Wct+E8DW3js5unXd+mPfH0VfyheTjks+uBzD57KkAk8+ODTD57AcBk89uEy75nr0sYPLZKQMmn104YPLZ4QMmX0g+Lvns8AGTzw4fMPns8AGTzw4fMPns8OGSH9jhAyafHT5g8tnhAyafHT5g8oXk45LPDh8w+ezwAZPPDh8w+ezwAZPPDh8u+cIOHzD57PABk88O36nIX01Tgou5Q365f9S++OX+qbf2h+clL2Flxt299IKEr1RhP5Cp8pupIkwVpsrvpQp7jUyV30wVdiaZKr+ZKuxjMlV+L1Uiex9Mla9UWTG5/JkaqcIKiKlyBbssN7ssuRzeSBVhqiCmypV81jTA5LNKASafdYdd8r27kx99RyHkO4251tA5OqyGtPKgJrw0Ka+3DSDvHwqay8HXFORTHEzBN6cgnyVhCr43BRO7OkzBN6cgn6thCr45Bfl0D1PwzSnInjlT8M0pKExBpuB7U5A7AkzBN6cg9yWYgm9OQe6OMAXfnILcHWEKvjkFuTvCFHxvCmbujjAF35yC3B1hCr45Bbk7whR8cwpyd4Qp+OYUFKYgU/C9KcjdEabgm1OQuyNMwTenIHdHmIJvTkHujjAF35yC3B1hCr43BQt3R5iCb05B7o4wBd+cgtwdYQq+OQW5O8IUfHMKClOQKfjeFGRfkCk4OQV9uKegxKcUrKyImYKTUzC7G+U+h/CcgqyImYJvTkFWxEzBN6cgK2Km4JtTUJiCTMH3piCfF2QKvjkF+bwgU/DNKci+IFPwzSnI5wWZgm9OQT4vyBR8awrGhbsj703BCyC33w65dFJw7Iee4sJ9CWDyuSMATD578cDkC8nHJZ/9Z2Dy2fkFJp89V2Dy2e0EJp99RlzyHTt8wOSzw2eE/Cud7NmZopNdOFN0Cuk8EZ2neIMyOvbrmFTDk4p9QCbV8KRif5FJNTyp2LdkUg1PKvZDmVSjk8qzz8qkGp5U7N8yqYYnFbvITKrhScVeNpNqeFIJk4pJNTqp2FFnUg1PKnbUmVTDk4oddSbV8KRiR51JNTyp2FFnUo1OqsCOOpNqeFKxo86kGp5U7KgzqYYnFTvqTKrhSSVMKibV6KRiR51JNTyp2FFnUg1PKnbUmVTDk4oddSbV8KRiR51JNTqphB11JtXwpGJHnUk1PKmEScWk+m5SbX8KOAqrPybVt5Oq8wUFYfXHpBqeVKz+mFSjkyqy+mNSDU8qVn9MquFJxeepmFTDk4rPUzGphieVMKmYVKOTis9TMamGJxWfp2JSDU8qdtTfm1Ti16SSD8Q2k8qLrGxKuX/B2KXWRGq8IeJqfsTvi3r2vWGpZ3calfrEHjIs9ez0wlLPfiws9eyawlIvpB6VenYg30z9Uu/U+w71Epy/IRIeEuVC/ZVNtv4sscmemyU22UazxCY7Y4bYzGx2WWKT/StLbLIlZYlNdpkssSlk0xCb7AVZYpO9IEtsshd0Jjblzubl/x7ZbPx0Tmv3v7jwTD0bR7DUs8uESn1hSwqWevavYKlnswuWenbGYKkXUo9KPXtusNSzQQdLPbt5Zqkv8jDt/Ew9u3mw1LObZ5f65NdpP07ki/rKbh4s9ezm2aW+uttP1yU+U89uHiz17OZBUN8o7qqQelTq2c2DpZ7dPEXUpw71bpH1tejl18ftGkHeP2ETvZNn6tnNM0u9l7RSnxrFHbt5dqmvK/UhPHfzKrt5oNSnhd08s9SHfDs4ysPn6lbq2c0zS73kG3wxLumZenbz7FKf0p36xoLPbp5Z6lO+1fUxu04TIKdwy5OcSnjOE2GeME9+I0/YJ2Se/E6esKnIPPmdPGEHknnyO3nCdiXz5HfyhL1N5slnntTbc+w5uydXiuTYCGWe/E6esGvKPPlgPK+zzjnU5zxhi5V58jt5wn4sYJ5cqRdSj0o9u6aw1LMRCks9e5uw1LNdCUs9O5Co1Hs2FWGpZ58Qlnq2/sxSX9xKfYm+0/rrbE16tv6YJ7+TJ8I8YZ78Rp6wqcg8+Z08YQeSefI7ecJ2JfPkd/KEvU3myWeebD865dkIZZ78Rp4Edk2ZJx+Mdx6dCmyxMk9+J0/Yj0W1NwlssXKJ+B3JIcwT5slv5AlbrMyT38kTtliZJ7+TJ2yxMk9+J0/YYmWe/E6pyxYr8+Q38kTYYmWe/E6esMUKagWfhF1TwCXiSj27prDUC6lHpZ69CFjq2V6ApZ4dA1TqI2UeLPVC6lGp5xY2LPVU+LDUU+HDUk+Fb5X65Pzt8dfk0vPjr4nbfHapX+ROfXmmnjt3sNRz5w6WerZ0zFJ/wfpGvY/pmXoh9Wav+jXIC/UNmceWDiz1fNEAlnp282CpZzdvOPVLeUX9FXJ20Y6GPLN7dTjk7Br9BuRlXffrEnuQu/Uu4Zy/T9vX3ArR32o8kfs9wpfWsWGtB4P4X469UskukBkq2dUxQ6WQSitUsutihkp2UcxQya6IGSrZ5TBDJbsnVqgs7MqYoZLdHjNUstvzXiqdX6mUDpX5DnSu9T5r30Q6xNsjnuLvcHxMqEHKaungvfOPB1+ThH0kJkk3SYRJwiTpJQl7X0ySbpKwq8Yk6SYJ+3VMkm6SsBPIJOkmCXuMTJJeklR2L5kk3SRhX5RJ0k0SdlyZJN0kYceVSdJNEmGSMEl6ScKOK5OkmyTsuDJJuknCjiuTpJsk7LgySbpJwo4rk6STJHlhx5VJ0k0SdlyZJN0kYceVSdJNEnZcmSTdJBEmCZOklyTsuDJJuknCjiuTpJsk7LgySbpJwo4rk6SbJOy4Mkl6SeLYJ2GSeB/uSSLxOUlY3TBJLj9wm7LPITwnCasbJkk3SVjdMEm6ScLqhknSTRJWN0ySXpJ4Pk/CJOkmCZ8nYZJ0k4R9EiZJN0n4PAmTpJskwiRhkvSShB3XfpLUsP50jbWTJCGuk3YPv9z8WlteA3zEwklrFnG5kR6T/+XYK5Hsihohkp1LI0Syu2iESHYAbRAZ2KUzQiQ7aUaIZLfLCJHsSBkhUkjkSYhMt2PTUjvHumVF2S2lPLSB0hft7ANB0s6u0W/QntY5L7VHe3Hp9tvFPxDU7uRKWdavLZWHXm6Q8EUQu0HKCWKXRzlB7N7oJkjYlVFOELstygliF0U5QeyOKCdISJBugtifUE4QOwnKCWIn4UCCrpCzN3A45Kz2j4Y8sn4fDbl3d8ij76z8b7P0iOwLgBLPfgMo8exjgBIvJB6TePZdQIlnPweUePaJQIlntwqUePbMMIlP7NyBEs/OHSjx7NyBEs/OHSjxQuIxiWfnDpR4du5AiWfnDpR4du5AiWfnDpP4zM4dKPHs3IESz84dKPHs3IESLyQek3h27kCJZ+cOlHh27jCJL6zjjRLf+dJxoao3SnzngytFSDwm8VT1oMRT1YMST1UPSjz340GJ5348JvGVdTwo8dyPByWe+/GgxAOo+mugACr2GqhJ1RZk+4ddWTvUrsj92zBfn4Ypi0lJ82NUTN7vf4yKyZvhj1ExucfzY1SEqDRQMbk78GNUTLbOf4yKSQX6Y1RMytUfo0Jt20DFUdu2UKG2baFCbdtChdq2hYoQlQYq1LYtVKhtW6hQ27ZQobZtoUJt20DFW9G2wYfbLILv/bAP/nawF3Hrwe3toLGf1rpsXBHyoyG3ospPBLkVyX8iyIWQHw25lWLlRJBbqYROBLmVMutEkFup4U4EuZUC8TyQB1afh0PO6vNHkF9BZD05AERWiANAFILYBfEU7h4lsJY0QyVrVDNUsvY1QyVrajNUsla3QqWwB2CGSvYWzFDJDocZKtlnMUOlkEorVLLbY4ZKdnvMUMlujxkq2e0xQyW7PVaojOz2mKGS3R4zVLLbY4ZKdnvMUCmk0gqV7PaYoZLdHjNUsttjhkp2e8xQyW6PFSoTuz1mqGS3xwyVQirPQuX2h0FLooI9DZXbX4ooiQrWDJVUsFaozFSwZqikgjVDJfcrzVDJ/UozVAqptEIl9yvNUMn9SjNUmun2hOBvVIbqOlTePXAu7bDco3KsXVY205U5D+RmuiengbyY6XKcB3Iz3YjzQG6ma3AeyM1U9+eBXAj50ZCbqZbPA7mZqvY8kLP6PBxyVp8/gvwKIuvJn4NYWSEOAJE1Xx/EczxDWVlLmqGSNaoZKoVUWqGSNbUZKlmrm6GSPQAzVLK3YIZKdjiMUFkX9lnMUMlujxkq2e0xQyW7PWaoFFJphUp2e8xQyW6PGSrZ7TFDJbs9Zqhkt8cKlY7dHjNUsttjhkp2e8xQyW6PGSqFVFqhkt0eM1Sy22OGSnZ7zFDJbo8VKj3rytNQuW3WXL2QyrNQue3EVD0VrBkqqWDNUEkFa4ZKKlgzVHK/0gqVgfuVZqhkXWmGSu5XmqGS+5VmqBQrVMpy++EgUR5/+BqomaqrF6iZmqQXqBXFLi7fViFxDxd/+4dfH/yJilgRv2NRsaIjv4VKKvHW6k8l329v6QsUK4psKChWtM1QUAQSlLrcppwuXdsnUKzsrgwFxco+xVBQrGjPoaBY0alDQYHUtB1QIqSk7YGCqWg7oGAq2g4omIq2A4oQlGdQqGgboFDRNkChom2AQkXbAIWK9hmUREXbAIWKtgEKFW0DFCraBihCUJ5BoaJtgEJF2wCFirYBChVtAxQq2mdQMhVtAxQq2gYoVLQNUKhoG6AIQXkGhYq2AQoVbQMUKtoGKFS0DVCoaJ9BKaCKVtYHAS+7PE+ggCrabVBAFe02KKCKdhsUISjPoIAq2m1QzinePufOr06f5/XAsNyO9cHJ48FXKvmmpxkqrdx7SCW/Om2HSvp6maGSvl5mqKSvlxkq6et1Hmfa6lcqlz8704aFX522QyV9vcxQyW6PGSrZ7TFDpZBKK1Sy22OGSnZ7zFDJbo8ZKtntsUIlP1Vsh0ozsseH2yyC7/2wD36lUsSdhMrNHuyFSjOyh1SakT2k0ozsIZVmNrngqfRmFCypNLPJRSrNbHLZp7JTV3ozm1ykUkilFSrZ7TFDJbs9Zqhkt8cMlez2mKGS3R4rVNr5VDGpZLfHDJVsEZih0ors8XW5TTk4t2z/cKx1hbvEO9zOxRbcNa1zXmpdjw51OW/H1szXYUn894g38wFcEv9N4q0IMBL/TeKtbM6R+G8Sb0Wnk/hvEi8kHpN4K9uEJP57dbyZ74qT+G8Sb2ULksR/k3h27kCJZ+cOk/jIzh0o8ezcgRLPzh0o8ezcgRIvJB6TeDZwMIlPFHd94ku5zfnCdewQfzn57Wjn/EOTvOZWiG79KI08HFuypr5+ohBkknSThKKRSdJNEmGSMEl6ScJtZCZJN0lYsTBJuknC7WkmSTdJuJXNJOn2SbjtzSTpJUnmFjmTpJsk7LgySbpJwo4rk6SbJOy4Mkm6SSJMEiZJL0nYcWWSdJOEHVcmSTdJ2HFlknSThM00JkkvSYowSfpJ4sPtp0tcekkiq4WYk3zHzi2h9dsXQG6/HXK58xNbR5/kDfVCocukGp5UFMZMquFJRSHNpBqeVHzUgUk1PKlYzTGpRidV5aMUTKrhScVHL5hUo/tUlY9qMKmGJxUf7WBSDU8qYVIxqUYnFTvqTKrhScWOOpNqeFKxo86kGp5U7KgzqYYnFTvqTKrBSeUWdtSZVMOTis1PJtXwpKJQf29SuXyf9gPS7aT6+LbyenTM96Objx6fY6fQLZT1TME3pyCLAKbge1PQsWRgCr45BfnIDlPwzSnIGpcp+OYU5ONATME3p6AwBZmCb+0LOj5qxBR8cwrywSSm4JtTkLsjTME3pyB3R5iCb05B7o4wBd+bgp67I0zBN6cgd0eYgm9OQe6OMAXfnILcHWEKvjkF2ZpmCr45BdmUsZuCLt1TcKmdpPqg487MfSZBwleqsHnCVLmCXZzc0C6uPqdKYJODqfKVKmuUUoJvpAqbEUyV30wVNg2YKr+ZKizumSq/mSrCVGGq/F6qsF/DVPnNVOEjf0yV30wVPprHVPlKlSWvqfLQ2b2nCru1TJXfTBV2a5kqv5cqwm4tU+U3U4XdWqbKb6YKu7VMld9MFXZrmSq/mSrCVGGq/F6qsFvLVPnNVGG3lqnym6nCbi1T5TdThd1apsrvpUqErIBy8Gt8WXqp4pK/PXXq8iP5H5tqLfJvsw7e587R/k6n9yF36DyJ+VYUJhWTanRSQVZVTKq5SQVZfzGp5iYVZKXGpJqbVJA1HZNqblJBPqvDpJqaVAnyqR4m1c+SqmMXkCCf/2FSzU0qyCeFmFRzk4oddSbV8KQSJhWTanRSsaPOpBqeVOyoM6mGJxU76kyq4UnFjjqTanhSsaPOpBqdVJnNTybV8KSiUB+dVMuyPsi7lN7RPqyPFHsRd5Kk6uz9ZQp1JtXwpKJQZ1INTyoKdSbV6KQqfPSFSTU8qVj9MamGJxUffWFSDU8qPvrCpBrdpyrCpGJSjU4qPvrCpBqeVOyoM6mGJxU76kyq4UnFjjqTanhSsaPOpBqdVJUddSbV8KRiR51JNTyp2FFnUg1PKmFSMalGJxWFej+p8hLXpEq1kyal3Lxk3bJ0c8qg6YtfqNOZU6NzijKdOTU6p6jSmVOjc4qPvTCnRueUMKeYU4Nzig+9MKdG5xSfeWFOje1P+YWPvDCnRucUn3hhTo3OKfbRmVODc8qxj86cGp1T7KMzp0bnFPvozKnROcU+OnNqdE4Jc4o5NTin2EdnTo3OKfY8mVODc8pTo4/OqfXgkkMvpQw6vFyuDaYUU2psSglTiik1NqUo0JlSg1OKz7kwpQanFEs+ptTglOJTLkypwSnFh1yYUmP7UoHPuDClBqcUH3FhSg1OKXbPmVKDU4rdc6bU4JQSphRTamxKsXvOlBqcUuyeM6UGpxS750ypwSnF7jlTamxKCVudTKnBKWVGnke5/bCPtWz/sCv19jivX8JZqOzsrYkZWUwqzchRUmlGBpJKMw8vwFMZzShpUmlms55Umtkkt09lp66MZjanSaWQSitUsttjhkp2e8xQyW6PGSrZ7TFDJbs9VqhM7PaYoZLdHjNUskVghsoBxUiON1ykLmH74BjzjfbyyE5uAb7UePtG6+XvdIc8fU0+n3nyRfXk11x3bnnIm9vk64knn5czT96defJe8eQvE673yfv0MPnGNFxdbzOX29NToAElUEEJNKIEqlkRDA1Us3oYGqhmpTE0UN2qZJ2G+8WJ9mvyRbcq6UxetyrpTF6zKulOXrPS6E5ezjx5zYqgO3nddX9n8rrr/s7kddf9ncmf+Q5bz3yHrWe+w9Yz32Hr0eu8v/UNo5T+5Le7jDWdefJZ9eS3e121nHny9byTD8ty5sk7xZMfWKyHxaMEGlACFZRANSuCoYFqVg9DA9WsNIYGqluVbCrxsOhWJduTd7pVSWfymlVJd/KalUZ38prVQ3fycubJ6677O5PXXfd3Jq+77u9M/sx3WHfmO6w/8x3Wn/kOO+LbfcmvujUvnQeCnWS5zSe6B/uv0jo6ye3gFN3DscvX5KPqyefbg8GpxMbkk+7Ju3XyqTH5fObJlzNPvp548iO+G/O+ybszT96fefJB9eTT7T2NlEpj8rrvsJ3J677Ddiav+w7bmbzuO2xn8rrvsJ3J677Dbk9edN9hO5PXfYftTF73HbYz+TPfYeXMd1g58x22/cZJ9LeXXKO/b2N9vbca2i9vdMaUHWPq98e0n+TvjHE7xvgdY8KOMbJjTNwxZkcetB8FjumW9/HhqbJ1TNkxpn5/TPt501jXbpTzz2PcjjF+x5iwY4zsGBN3jEk7xuQdY8qOMfXbY2RZdoxxO8b4HWOa8fjsVl+EHMLTqPZetktpfbQtFfc8yu0a5XeNCrtGNTP80hS/LUHu0X5iHRV3jUq7RuVdo8quUXXPqPYuTHeU2zXK7xoVdo3alRt+V274Xbnhd+WG35UbfldutDu3rrqbPnTVN0a5PaPaktiXdY/Ml4cZXm7WDeFairstnqVK7R3t0t3yZbkf3TZxkbLcXlKQ8mDjcon3K4B09gDy2QMoZw+gnjyAttv/mQJwZw/Anz2AcPYA5OwBnP1OHM9+J45nvxNHVXfi65RU3Vs/p5RU3S2vUzr+/qfEeNGtfRfvG42X5AlMG5hAYNrACIFpAxMJTBuYRGDawGQC0wamEJg2MJXANIHJC4FpA0Pl+wIYKt8XwFD5vgBGCEwbGCrfF8BQ+b4Ahsr3BTBUvi+AofJtA1OofF8AQ+X7Ahgq3xfAUPm+AEYITBsYKt8XwFD5vgCGyvcFMFS+L4Ch8m0DU2F1jA93YOT5meMKe1fqvDBSYe9KPWBg70o9YGDvSj1gYO9K28DEBbYf0wMGth/TAwZWx/SAge3H9IARAtMGpql8w7JaL4alhE6ozhW5WVBc/k6+c7y//N+qxsMD7N5/TSqNmFQueZ1UdanH19AH32PbmP5cIZTzh1BPH0L7lf1zheDOH4I/fwjh/CHI+UOI5w/h/Hdnp+zufJ2UsvvtdVLK7qCfk/LvuCeeosUfvSM0r6DxhOYVNIHQvIJGCM0raCKheQVNIjSvoMmE5hU0hdC8gqYSmhfQBKrhl9BQDb+Ehmr4JTRUwy+hEULzChqq4ZfQUA2/hIZq+CU0VMMvoaEafgWNUA2/hIZq+CU0VMMvoaEafgmNEJpX0FANv4SGavglNFTDr6CJwLpm++2tGIHvUJ3HeyPwHaoHDfAdqgcN8B2qBw3wHaoHDXC/pgcNcL+mA00C1jU9aID7NT1ogPs1PWiA71BhuR3rg5NnaIDvUD1ogO9QHWgy8B2qBw3wHaoHDfAdqgcNcL+mB40Ad/nq+lZ4WJ67fBm4X9ODBrhf04MGWA33oAFWwz1ogNVwB5qCvA/VgQZYDfegAVbDPWiA1XAPGkq+V9BUWNO8TgVVYU3zesDAmub1gIE1zesBIwSmDQysXXQPGFi76B4wsHbRPR0DaxfdAwbWLnobmIRrF90DBlb59oDB/exFBxhY5dsDRghMGxhY5dsDBlb59oChwGsD07YUzsst0vzwEpDLX2PCjjHNtSyHG/75AdB1TGyPuQWUU3ge07wCcqkruvl5TN4xpplQxd+IKdLAoLbHrHkS09OYtsloyX7NxOe5td0372Nqg5/2KzpuWZ/ydEsqT9nTfnulO6rJkXNrMjgX3fOovGtU2TWq7hnVfojc3X1knSvPaKTm1eRkWW6jZGmcS3aNirtGpV2j2nxFv2IY4/I8quwaVfeMaj9S2R3ldo3yu0aFXaNk16i4a1TaNWpXbuQXubEubO6yvfA8qu4ZVZZdo9yuUX7XqLBrlOwaFXeNarMc3DoqhOd1o/1B0e6oumdUe/+yO8rtGuV3jQq7RsmuUXHXqLRr1K7cqLtyo77IDVl35C8Fwp9H5WXZNcrtGuV3jQq7RsmuUXHXqD3KIbe/WtQdVXaNqntGvapM1opBwvOY5vyqrKo8xucx9ftj2hVDZ4zbMaads9vaP7c93rujZNeouGtU2jUq7xpVdo2qe0a1DXq7o9yuUbtyI+zKjbArN8Ku3Ai7cqNtIbi9WrS99eraY6n+eYzsuPLbvlqd88iOMXHHmLRjTN6BwY6VWXaszHEHP3HHyhz9jjFhx5h2HsRbXtfsn8fEHWPSjjF5x5iyY0z9/ph2n6gzppcHrTE78iDtyIN2L6ozJu4Yk3aM2bEepB3rQdqxHuQd60HesR7kHXmQd+RB3pEHeUce5G/mweUf7uPAtvbM6z5Nfrh3uxgauymy7glEt/xy7GVibZH6rZ93t6ojhvz083Huz6e5P5/n/nyZ+/N16s+3pfm4n2+uGZeSfv352vl5v9T7NuLl7weNW+LnKfz8U4T5p5D5p4g/PYXkuu7+lvDrCZ6PrnndfFqWhwZNbG0WXyrLdRq+c6xzct8Meyx6mkfHfDs41ocAy7VBR0j+DEkmJH+GpBCSP0NSCcmfIGm3QIau4DL7bnr5l/84un03uuzg3U708FSRE3l9d9kekr4/JH9/SPn+kPrtIS/Yr7d8KcvzEPf9IU2tU/L6cNjD26C3IeH7Q6TT/HLPQ+L3h7RLqbU1WaU8DcnfH1I6Qx4KttuQ+u0hL9prm0Pa1XS5iela6tMQ//0hr/ra6d41/nVqz2tGWsrXwck/PCVWls8TyOwTxNknSLNPkGefoMw+QZ18grTMPoGbfQI/+wSzr+Q0+0pOs6/kNPtKTrOv5DT7Sk6zr+Q8IotWe4v08Kjr7QQjOEg3DZwe21tfJ/g2Bx+D6o5BZdkzKE8GuIzIwbVcSyU+nWBEDma3nuApB+sy+wRu9gn87BOE2SeQ2SeIs0+QJi80dfZKVsvsE9TJJ3DLMv0MbvoZ/PQzhOlnkOlniNPPkKafIU8/w9xL+vKv8HGke/Ga1HJvw7qlPg7+HCufY1+B4NYphocpfr4E5sqOMfX7Y/yyY4zbMcbvGBN2jJHvj3m1Dbj1CuW3R7Q3kbZeuXzxoOLGC5ftLYiNVydf9Gi3RrRfZ9x41fJFh3bjRctXDdrXr1m2+7OvX7K8/CNuXtX+flGX37vKnNwXgvRLRH98f9lIHwe365qUwrIuVg/vV4RYXtcqvUF1x6B2TdEb5PYM8nsGhT2DZM+guGdQ2jNoT0bUPRlR92TEC23aHeV2jfK7RoVdo2TXqHZeZLmtlSnn5XnUi6311e4gLyE9j6p7Rrll1yi3a1Sbr1rr5qgXz16sbzrlJT8j78quUXXPKL/sGvVCDtwVRPDPaLx4sK43qu4Z9eIxuN4o90LmrBvyIebnUX7XqLBrlOwaFbujHh6sWEe94KvcRz3c+9dRdc+oF1KuN8rtGuV3jWojL37NKHn4dtk6qu4Z1d4YziXeyoBcUmNUm2VJZT3Xw/Mk66i0a1TeM6q9LZjjw4MY9TkP2ztl+f5gRS6N+1d7+6s7Ku5BPqVdo/KuUWXXqLpnVF52jXK7Ru3K+fa7Bd1RsmvUrtzIu3Ij78qN9gZUTg9Pf/vnu0PbaaI7yu8aFXaNkl2j4q5RadeovGtU6Y5qrFHterc3qi67Rrldo17kRlrX3pSf77Dt+vBSZaw5nx+MiNdRZdeoumOUb1eI3VEvMKz5Pio+j/K7RoVdo2TXqLhrVNo1Ku8Z9aJCzKtV3+XPZ75eVIiPysH9uvY2emRS4k0KXf5+znb/wi2vrJ3/lj7xbo8W8k52jYq7RqVdo/KuUeXboy7/yh/Hple2bHe3jks5+ETbC5+v7jC3b5jfNyzsGyb7hsV9w9K+YXnfsPaGVIrrI72Xv59r4BePAfWGvXgQqDvM7RvmXwxbn4a4/F2eh4V9w9oEpPvT9JfCZnnSOi+eQkr3dzvcR2/xv36rt98d9uKJoe4wt2/YCwIuGv0+7Lml8OKZne4w2Tcs7huW9g3L+4aVfcNeZEm5LwqpuN/t+P/GOLdz3KtEebjkivM9beGzrMf7ixbvHR/juiV6+bs+92WWoHReonReUem8ktJ5ZaXzKkrnVXXOyy3vmte6rsa0PO86OjdoXndTZp//1L9u1nhr4X/52z13rp1XOq/8pnlt18Qvdj4VzKvqnJdflM7LKZ2XVzqvV3oiPsje1BiXdo7LO8eVnePqvnFh2TnO7Rznd44LO8fJznE78yXszJfwIl9KyPfrpvXcQdk5ru4bJ8vOcW7nuBe817u+STU97z6I7Bz3goea7vOsubFb38YlX24gt3HZNZ5far/T/hvj/M5xYec42Tku7hyXdo7LO8eVnePqi3HrYxqXv8uznk6v8uWeZ9nV3h5IqqsMTdU9PPRcmt84Wt9hLP6hx+m+ZuTUzcirm1FQNyNRN6OobkZJ3Yyythm92HXLfn1o9+Pvp/3fF08HXY5dN4AvfzfWvxdbWtmH+7rp5Xef9fmNcS8Q9+lhno37+otdrXz/dvPlb/9c/7/Y1uqOe7Gv1R/ndo7zO8eFneNk57gX+RLkYVx8zs+Sdo7LO8eVneNe5Ut4HPesP+qyc5zbOc7vHBd2jpOd4+LOca/y5d4fvfz9vE7UvHNc2Tmu7hr34vmqy7H5YVxdnse5neP8znFh5zjZOS7uHJd2jnuRL/JwvxUfnseVnePqvnEv9iP6417kiyyP4xpPhvmd48LOcbJzXNw5Lu0cl3eOe5Evvtx1j4T4X73+anDr8dK4P/sX/fvvn2d9Yebyd+zuW3WfAfTLoHlFuc/r+blw/6If/7P4W+fxB50nHHQeOeg8cdB5crqfp/qf52caNK96j/+yJjyfJ4+Pv3mectB56jHnCctB5xm0fojL9/OEnz9DHQatNxIe4pfn58hDmBB/6zxy0HniQedJB50n7+rz+FB2jqv7xsmyc5zbOc7vHBd2jpOd4+LOcWnnuJ35IjvzRXbmy4t9tN5+n4+v9iXrve5blmed/GIfrT8u7hyXdo7LO8eVnePqvnEv9tH649zOcX7nuJ35knbmS9qTL5d/lY+jfd7jWONz2jUq7xpVdo3a41rjy7JrlNs1yu8aFXaNkl2jduVG2ZUbuxyu/C6LK7/L48rvMrnyu1yu/C6bK//C52rbZcjXFwZ2mx4+/sX7xb1RZdeoPY5G4YUD1bbLUFheGQBuefiEJe0alXeN2uNoFF59GX3Twye8eP+0NyrvGlV2jXrhkLPp4RNeODX1Rrldo/yuUX1Ho+eXF8OLj0Vuu/GEVw5UnVFl16g9jkYhLLtGtZHf9gsKL+w5O6Nkj7tLaNeGHeef8Mo9qTMq7hrVZnnbZSjE/lv/z/ev8MKpqTdqj2tNaFdn3VFx16i0a1TeNarsGrXH0SikXTmf3K5RfteoXbmRduXGLrerkPquNc9eNyHVPaPysmuU2zXK7xoVdo2SXaPirlF9R6PGGpXzrlFl16g9jkbhldvVpstQeOEKte3hE164QvVG5V2jyq5RLzDcdMgJr1yhOqPcrlF+16iwa5TsGhV3jXrB16bLUHjlQDXUZUheOFZtuwzJskcLyeJ3jQq7RsmuUXHXqO87Gl3+VT97lc2hsr5uGB9988Vd24DfH1K+P6R+e0i7oNke4r4/pJlEcfXCj9U9DQnfH9JuLq5XRfrlg7Duux9Ne/Ht3GE/n+b+fJ7782Xuz9epP98umsf9vJv7837uz4e5Pz/3qpW5V63MvWpl7lUrc69amXvVxrlXbfx55mx9wTH+HPutj1DFb2L/D6++77s9xH1/SJgKa/r5crL1Wcz086TY+pxhSnN/Ps/9+TL35+vUn8/L3J93c3/eT11Ocpj78zL35+Pcn09zfz7P/fm5N6Jcp/58Web+vJv783Ov2jLzqv2vD0+7j0PbLzT56m/Lla+P3wWMX2Pdx8Ft9R/XTyPGeH9QxIX6WtFvD0nfH5K/P6R8c8gHCv6zo9Re/laH4LI8CJEQP3s98ftD0veH5O8PKd8fUr89pN23Kqulb5HyNMR9f4j//pDw/SHy/SHx+0PS94fk7w8p3x9Svz2k3a8p67MA5cHm8mPI87p22SX9Ovaya7ceGyS97teM+3k/9+fD3J+XuT8f5/58mvvzee7Pl4E/X8LTz9epPx+XuT/fvGrr+hngGvKf15H2gz7bQ8L3h8j3h8TvD0nfH5K/P6R8e0i7bN8c0i7Ft4c02ffrF5B9yn9OmHbJvD0kfH+IfH9I/P6Q9P0h+ftDmuz7nFeh/3RVtsu/zSHtkm57iPv+EP/9IeGbQ/7r8s//75/+/a//9M9/+9f/uAz5+F//z7/9y3/+9e//9vXP//z///ftf/nnf//r3/721//1j//73//+L//6P/7Pv//rP/7t7//y8b/9Zfn6f/89pOD+uCyC/kM2ffxbQvgjiIR/uNZi/91f/ncf0j9cy6vL8b5cjg/LZ6nxWat9HCXhDym3Y6T+Ed3H/+5vZ3GXH3HrOdylfnHe3c7gvL/8M99Gu8sJ3PX3w/r7rv7h5eM/yfqfPuYR7t84//xP+Y/g1y+LX2ef/vAxf5340u0q62n9pZj0fg3Mh+USp18//HM9RfojLLfRcfkjLevoVP7wOayjs1z+mdaXjz4x8fKHSPwa7eMlhFRv42Wpf4iTFTJX/hC/rA8EfMa8pC9cPsZfplLTbXTNf7jFr4gt4fLP+FA+fw6/RO7uZfEnue5yzttvXMKJ8V4wfv63S2meViJK/aNefuC/Lkn3/wA=",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "exit_to_l1_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17456365777023668047": {
            "error_kind": "string",
            "string": "Token address is not the same as seen in storage"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3djuy6ciT8Lud6X/An+TevMjAM2+MZHODAZ2B7PuDDwO8+1V0tVa1dVHO1mmwFmeELo9c+YikVEUwmQ0rp//7lf/zrP/+f//WPf/23//n3//jLf/vv//cvf/v7v/zTf/717/92+9f//YuV9//2H//7n/7t7Z//8Z//9O//+Zf/5iSXP/7yr//2P25/hiD/9cdf/udf//avf/lv1t7+fj3ambgd7Vzej86xdnDOaTu4RPP5wTYUux19+9s/DnfJ1o6PIW+Hx5QeR+dcO9pHvx0t1vxy9D/88RcbCM0RNJHQHEGTwKEJ8oAm5gY0zro9Eivhm9BkQnMETSE0B9A4Q2iOoLF1aJx/QBMa0IgN4eNoscXuR0d5P4MbfgZfO4OVbMx+5cW3zmG9s9vhPsSno6sJ33i/LxDGP8knVtXjjWy/fvs7mT9fgsx/CdVaxwYvu/7Cbcb9cglvw6p1QMppu/CUnwa9KeVVHSbu6nDeP84QXe2yk9lBSvI07Yt7jyeBxZPB4ilY8XgDFo8Fi8eBxePB4hGweMIPx+N8cVtal1he4vnp/OxuUezxlF/xqS1isq+Q5u33Pj06FdkiSaX4RqF1W0L3sJ8Kp+rimOxeS6anS6webFOKuwJKaBxs9l++XWB+PviNnUR2gNn56bXbBRsfVbVv4P1kcTyTU2rbiOzsFkd2wTW4WY/JQibXYFIMmVyESQvNpHV5d3XE2Wcq34J3MwfvsYMvD1+jRP/5JLrNhW0O2acpFHO1+LH+4QGmX45+g0UISw2WQFhqsEStsPh9v+nkFZZEWGqwYG8lLoMFuy4fCEt4wJLsn2EJ2EXuZbCAV4xXwQJeiw5coJ9gcS+wqK1y0+NOd4kvsAhhqcGitsr9HBa1Ve5TbikvdUtYqMrN8eHxPz2iUMdlnAvlHrexvGkZS35nx3pvv+NChYUKc+VMLrSXAGHyImc4LrT9Uc7kQju2bky+4YK+ZbP77YPypIB6WSUbhumZ/1x99jXvQbucH+nevldVEX3Hdg0qQlQqqKDv165BBX27dg0q6Lu1a1BB3/lcgwr6LuISVBJ6RX4NKujV7TWosLatocLatoaKEJUKKqxta6iwtq2hwtq2hgpr2xoqrG0rqGTWtjVUWNvWUGFtW0OFtW0NFSEqFVRY29ZQYW1bQ4W1bQ0V1rY1VFjbVlAprG1rqLC2raHC2raGCmvbGipCVCqosLatocLatoYKa9saKqxta6iwtq2gYg2L2yosrG6rsLC8rcLC+rYKi6wDy+NKcza/wPJ+pQsVrY0rXagQLfHxniljG1oP3m09GsGHp5mh40VT1ixUa5P4rxC/0HaCxH+F+IV2TCT+C8TbhfaEJP4rxC+06yXxXyF+oX09if8K8Qs5FyT+K8QLiddJ/EJWFYn/CvF07pQST+dOKfF07pQST+dOJ/GOzp1S4uncKSWezp1S4uncKSVeSLxO4uncKSWezp1S4uncKSWezp1S4unc6STe07lTSjydO6XE07lTSjydO6XEC4nXSTydO6XE07lTSjydO6XE07lTSjydO53EC507pcTTuVNKPJ07pcTTuVNKvJB4ncTTuVNKPJ07pcTTuVNKPJ07pcTTudNJfKBzp5R4OndKiadzp5R4OndKiRcSr5N4OndKiadzp5R4OndKiadzp5R4Onc6iY907pQST+dOKfF07pQST+dOKfFC4nUST+dOKfF07pQST+dOKfF07pQST+dOJ/GJzp1S4uncKSWezp1S4uncKSVeSLxO4uncKSWezp1S4uncKSWezp1S4unc6SQ+07lTSjydO6XE07lTSjydO6XEC4nXSTydO6XE07lTSjydO6XE07lTSjydO53EFzp3Somnc6eUeDp3Somnc6eUeCHxOomnc6eUeDp3Somnc6eUeDp3Somnc6eSeGfo3Cklns6dUuLp3Cklns6dUuKFxOskns6dUuLp3Cklns6dUuLp3Cklns6dTuItnTulxNO5U0o8nTulxNO5U0q8kHidxNO5U0o8nTulxNO5U0o8nTulxNO500m8o3OnlHg6d0qJp3OnlHg6d0qJFxKvk3g6d0qJp3OnlHg6d0qJp3OnlHg6dzqJ93TulBJP504p8XTulBJP504p8ULidRJP504p8XTulBJP504p8XTulBJP504n8ULnTinxdO6UEk/nTinxdO6UEi8kXifxdO6UEk/nTinxdO6UEk/nTinxdO50Eh/o3Cklns6dUuLp3Cklns6dUuKFxOskns6dUuLp3Cklns6dUuLp3Cklns6dTuIjnTulxNO5U0o8nTulxNO5U0q8kHidxNO5U0o8nTulxNO5U0o8nTulxNO500l8onOnlHg6d0qJp3OnlHg6d0qJFxKvk3g6d0qJp3OnlHg6d0qJp3OnlHg6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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "12741719456629472615": {
            "error_kind": "string",
            "string": "User's clean hands SBT has expired, cannot claim tokens"
          },
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "1336631728488611437": {
            "error_kind": "string",
            "string": "User does not have a clean hands SBT, cannot claim tokens"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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KBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUA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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "CleanHandsSBTContract"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sbt_count",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "sbts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "address_to_sbt_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "nullifier_to_sbt_id",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "cleanHandsSBTContract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "cleanHandsSBTContract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_for_L1_to_L2_message_consumption",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_config_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "cleanHandsSBTContract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_config_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "107": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "110": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "114": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "115": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "116": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "118": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "119": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "129": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "132": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "136": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "138": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "140": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "141": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = array::subarray(returned_message, 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"
    },
    "144": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "145": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "146": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "150": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\n) -> [Option<RetrievedNote<Note>>; S]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "152": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "153": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "162": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "179": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "181": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "183": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "184": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "186": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "188": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "210": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "246": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "253": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "254": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "268": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "270": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "271": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "285": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "287": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "288": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "297": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "322": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "326": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "327": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "343": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "344": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "346": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "358": {
      "path": "/home/caleb/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "390": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "391": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr",
      "source": "// docs:start:mint_to_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::{hash::sha256_to_field, traits::ToField};\n\n// Computes a content hash of a deposit/mint_to_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_public_content_hash(owner: AztecAddress, amount: u128) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector =\n        comptime { keccak256::keccak256(\"mint_to_public(bytes32,uint256)\".as_bytes(), 31) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_to_public_content_hash_nr\n\n// docs:start:get_mint_to_private_content_hash\n// Computes a content hash of a deposit/mint_to_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_private_content_hash(amount: u128) -> Field {\n    let mut hash_bytes = [0; 36];\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { keccak256::keccak256(\"mint_to_private(uint256)\".as_bytes(), 24) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_to_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(\n    recipient: EthAddress,\n    amount: u128,\n    caller_on_l1: EthAddress,\n) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector =\n        comptime { keccak256::keccak256(\"withdraw(address,uint256,address)\".as_bytes(), 33) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "55": {
      "path": "/home/caleb/Desktop/work/Holonym/aztec/packages/aztec-contracts/token_bridge/src/main.nr",
      "source": "mod config;\n\n// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract TokenBridge {\n    use crate::config::Config;\n\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{functions::{initializer, private, public, view}, storage::storage};\n    // docs:end:token_bridge_imports\n\n    use dep::clean_hands_sbt::{CleanHandsSBTContract, sbt::SBT};\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal: EthAddress, cleanHandsSBTContract: AztecAddress) {\n        storage.config.initialize(Config { token, portal, cleanHandsSBTContract });\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    // docs:start:get_config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n    // docs:end:get_config\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: u128, secret: Field, message_leaf_index: Field) {\n        // Make sure user has Clean Hands SBT\n        let sbt_contract = CleanHandsSBTContract::at(storage.config.read().cleanHandsSBTContract);\n        let sbt: SBT = sbt_contract.get_sbt_by_address(to).view(&mut context);\n        assert(sbt.minter != AztecAddress::zero(), \"User does not have a clean hands SBT, cannot claim tokens\");\n        // TODO: is context.timestamp the timestamp in seconds or milliseconds? sbt.expiry is seconds.\n        assert((sbt.expiry * 1000) > context.timestamp(), \"User's clean hands SBT has expired, cannot claim tokens\");\n        \n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        let config = storage.config.read();\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, config.portal, message_leaf_index);\n\n        // Mint tokens\n        Token::at(config.token).mint_to_public(to, amount).call(&mut context);\n    \n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: u128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Make sure user has Clean Hands SBT\n        let sbt_contract = CleanHandsSBTContract::at(storage.config.read().cleanHandsSBTContract);\n        let sbt: SBT = sbt_contract.get_sbt_by_address(context.msg_sender()).view(&mut context);\n        assert(sbt.minter != AztecAddress::zero(), \"User does not have a clean hands SBT, cannot claim tokens\");\n        // TODO: is context.timestamp the timestamp in seconds or milliseconds? sbt.expiry is seconds.\n        assert((sbt.expiry * 1000) > context.timestamp(), \"User's clean hands SBT has expired, cannot claim tokens\");\n        \n        let config = storage.config.read();\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(config.token).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n\n    // docs:start:claim_private\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: u128,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        // TODO: How can we check timestamp in this private function?\n        // Make sure user has Clean Hands SBT\n        // let sbt_contract = CleanHandsSBTContract::at(storage.config.read().cleanHandsSBTContract);\n        // let sbt: SBT = sbt_contract.get_sbt_by_address(context.msg_sender()).view(&mut context);\n        // assert(sbt.minter != AztecAddress::zero(), \"User does not have a clean hands SBT, cannot claim tokens\");\n        // // TODO: is context.timestamp the timestamp in seconds or milliseconds? sbt.expiry is seconds.\n        // assert((sbt.expiry * 1000) > context.timestamp(), \"User's clean hands SBT has expired, cannot claim tokens\");\n\n        let config = storage.config.read();\n\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            config.portal,\n            message_leaf_index,\n        );\n\n        // At last we mint the tokens\n        // docs:start:call_mint_on_token\n        Token::at(config.token).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n        // docs:end:call_mint_on_token\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: u128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // TODO: How can we check timestamp in this private function?\n        // Make sure user has Clean Hands SBT\n        // let sbt_contract = CleanHandsSBTContract::at(storage.config.read().cleanHandsSBTContract);\n        // let sbt: SBT = sbt_contract.get_sbt_by_address(context.msg_sender()).view(&mut context);\n        // assert(sbt.minter != AztecAddress::zero(), \"User does not have a clean hands SBT, cannot claim tokens\");\n        // // TODO: is context.timestamp the timestamp in seconds or milliseconds? sbt.expiry is seconds.\n        // assert((sbt.expiry * 1000) > context.timestamp(), \"User's clean hands SBT has expired, cannot claim tokens\");\n\n        // docs:start:assert_token_is_same\n        let config = storage.config.read();\n\n        // Assert that user provided token address is same as seen in storage.\n        assert_eq(config.token, token, \"Token address is not the same as seen in storage\");\n        // docs:end:assert_token_is_same\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_private\n}"
    },
    "56": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "57": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "70": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "71": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "72": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "73": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "79": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "86": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "98": {
      "path": "/home/caleb/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    }
  }
}
